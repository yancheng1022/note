# 1、1-3级别



## 1.1、解释执行和编译执行

![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202404122302679.png)

Java语言既具有编译语言的特征又具有解释语言的特征。因为Java程序要经过先编译，后解释两个步骤。由Java编写的程序需要先经过编译步骤，生成字节码（后缀名是.class的文件），这种字节码必须由Java解释器来解释执行

编译型：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译型语言的执行速度较快常见的编译性语言有C、C++、Go、Rust等等。
解释型：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言执行速度比较慢。常见的解释行语言有Python、JavaScript、PHP等等。

>在运行之前，编译型语言将源代码转换为机器语言的可执行文件。这个过程通常称为编译。因此，在执行时，不需要再解析和翻译代码，而是直接执行编译生成的机器代码

## 1.2、值类型与引用类型

一、值类型分为：byte，short，int，long，float,double，boolean，char
二、引用值类型 除了值类型外就是引用值类型了，引用值类型有类类型(class)，数组， 接口类型(interface)，String等

值传递和引用传递的区别：对形参的修改不会影响到实参。

java是值传递，对于基本数据类型，是将数据创建一个副本传递到方法中，所以形参修改不会影响到实参。对于引用数据类型，传递的是对象的引用，即使形参通过这个引用修改了所引用地址的数据，但这个实参本身是不变的（就像两个遥控器遥控一个电视，2改变了电视内容，但1这个遥控器本身是没有变化的）

## 1.3、面向对象基本要素

封装：我们编写的一个实体类就是对数据和数据操作的封装，我们编写的方法就是对实现细节的封装。封装就是隐藏一切可以隐藏的东西，对外提供最简单的编程接口（普通洗衣机和全自动洗衣机之间的差别）

继承：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度

多态：父类的引用指向子类的对象。java实现多态三个必要条件：继承，重写，向上转型（父类引用指向子类对象）。多态存在的意义，通过多态性，我们可以在运行时根据对象的实际类型来决定调用哪个重写的方法。这样，我们可以使用统一的接口来处理不同类型的对象，并根据对象的实际类型执行适当的操作，如果需要增加新的功能，只需创建对应的子类并重写方法，而不需要修改现有代码

## 1.4、= =和equals

== 的作用：  
　　基本类型：比较的就是值是否相同  
　　引用类型：比较的就是地址值是否相同  
equals 的作用:  
　　引用类型：默认情况下，比较的是地址值。  
注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同

## 1.5、接口和抽象类

**接口的设计目的，是对类的行为进行约束**（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。对“接口为何是约束”的理解，我觉得配合泛型食用效果更佳。

**而抽象类的设计目的，是代码复用**。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。

## 1.6、动态代理、反射

反射：Java反射（Reflection）是Java编程语言的一个特性，它提供了在**运行时检查、访问和修改类、方法、字段等程序结构的能力**。通过反射，我们可以**在编译时不知道具体类**的情况下，**动态地加载类、创建对象、调用方法和访问字段**

动态代理：当我们创建一个动态代理时，Java会动态地创建一个实现了一组接口的代理类，并在该代理类中实现了这些接口中的所有方法。当我们通过代理对象调用方法时，实际上是调用了代理类中的相应方法。代理类在调用方法之前和之后会执行我们定义的拦截器代码，从而实现了方法调用的拦截和增强。

## 1.7、静态类型和动态类型

静态类型语言是变量定义时有类型声明的语言
动态类型语言是变量定义时没有类型声明的语言

java是一种静态类型的编程语言。在编译时，编译器会检查代码中的类型错误，并确保变量和表达式具有正确的类型。
然而，Java也有一些动态类型的特性，如反射和动态绑定（多态）

## 1.8、java异常


![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png)


Error：错误，无法被处理的

Exception：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常
- 运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。
- 非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过

## 1.9、String 和 StringBuilder、StringBuffer 的区别？

1. 可变性
String类中使用字符数组保存字符串private final charr value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的

2. 线程安全性
String是不可变的，可以理解为常量，所以线程安全。StringBuffer加同步锁，所以线程安全，stringBuilder没加，线程不安全

3. 性能
每次对String改变都会生成一个新的String对象。StringBuffer和StringBuilder对对象本身操作。性能 StringBuilder > StringBuffer > String


## 1.10、包装类

Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，

从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换

> 自动拆箱：在Java 1.4及以前的版本中，我们必须手动调用包装类型的intValue()、doubleValue()等方法才能将其转换为基本数据类型。而在Java 1.5及以后的版本中，我们可以直接将包装类型赋值给基本数据类型变量，Java编译器会自动将包装类型转换为对应的基本数据类型
> 自动装箱：Java自动装箱（Autoboxing）是指Java编译器在需要的时候，会自动将原始数据类型转换为对应的包装类类型（Integer b = 3）

```java
class AutoUnboxingTest {
	public static void main(String[] args) {
		Integer a = new Integer(3);
		Integer b = 3;
		// 将 3 自动装箱成 Integer 类型
		int c = 3;
		System.out.println(a == b);// false 两个引用没有引用同一对象
		System.out.println(a == c);// true a 自动拆箱成 int 类型再和 c比较
	}
	// 如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f3f4 的结果是 false
	public static void main(String[] args) {
		Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
		System.out.println(f1 == f2); // true
		System.out.println(f3 == f4); // false
	}
}
```


## 1.11、容器


![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png)


|名称|底层|线程安全性|扩容机制|备注|
|--|--|--|--|--|
|ArrayList|数组|线程不安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|
|Vector|数组|线程安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|
|LinkedList|双向链表|线程不安全|不主动扩容|增删快，查找慢|
|HashSet|HashMap|线程不安全||可以存null|
|LinkedHashSet|LinkedHashMap|线程不安全||可以存null|
|TreeSet|TreeMap|线程不安全||不允许存null|
|HashMap|数组+链表（jdk7） 数组+链表+红黑树 （jdk8）|线程不安全|首次创建长度16，扩容2倍,负载因子0.75|可以存nul|
|LinkedHashMap|同hashmap|线程不安全|不主动扩容|可以存null|
|HashTable|数组+链表|线程安全|首次创建时长度为11，扩容为2n+1|不能为null|
|TreeMap|红黑树|线程不安全|TreeMap由红黑树实现，容量方面没有限制|不能为null 可以实现自然排序和定制排序 |
## 1.12、I/O分类

一个完整的IO包括下面几步：1、应用程序进程向操作系统发起I0调用请求。2、操作系统准备数据，把I0外部设备的数据，加载到内核缓冲区。3、操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区

1、阻塞I/O
应用程序发起IO调用，内核数据还没准备好，应用程序进程就一直在阻塞等待，那就是阻塞IO
经典应用：socket，BIO

2、非阻塞I/O
如果内核数据还没准备好，可以先返回错误提示给用户进程，用户进程通过轮询方式请求。（非阻塞会阻塞数据拷贝阶段，不会阻塞等待阶段）
经典应用：NIO

3、I/O多路复用
解决非阻塞I/O频繁轮询的问题，系统给我们提供一类函数（select、poll、epoll），它们可以监控多个fd（文件描述符）操作，任何一个返回内核数据就绪，应用程序再发起recvfrom系统调用

4、同步I/O
无论是阻塞还是非阻塞，都等待内核把IO处理完成后才返回

5、异步I/O
当发起I/O后，调用者不能立刻得到结果，而是在内核完成IO操作后，通过信号或回调来通知调用者

![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202404131600302.png)



# 2、4-6级别

## 2.1、linux命令

ls: 最基本的文件信息的显示命令,以纯文本格式显示文件信息,每个文件单行显示，之后可以增加不同选项: -l (显示详细信息)、-a (显示隐藏文件)
ll: ls -l 的缩写

