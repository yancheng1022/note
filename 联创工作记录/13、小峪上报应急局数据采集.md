```java
package net.lantrack.module.monitorxml.handle;  

  
/**  
 * @Description 队列处理  
 * @Author zjb  
 */@Component  
@Slf4j  
public class QueueExcuteXml {  
  
    @Value("${reportInfo.mineCode}")  
    private String mineCode;  
    @Value("${reportInfo.reportSjOrYj}")  
    private String reportSjOrYj;  
    @Value("${reportInfo.tableName}")  
    private String tableName;  
    @Value("${baseInfo.mineName}")  
    private String mineName;  
  
    /**  
     * 钉钉机器人地址  
     */  
    @Value("${alarm.ding-talk.url:}")  
    private String dingTalkUrl;  
    /**  
     * 钉钉通知人员  
     */  
    @Value("${alarm.ding-talk.noticePerson:}")  
    private String[] noticePersons;  
  
    //执行采集解析任务的线程池  
    @Resource(name = "collectParseFileExecutor")  
    private TaskToolExecutor threadPool;  
    //执行上报应急局任务的线程池  
    @Resource(name = "reportYJJExecutor")  
    private TaskToolExecutor reportYjjThreadPool;  
    //执行上报省局任务的线程池  
    @Resource(name = "reportSJExecutor")  
    private TaskToolExecutor reportSjThreadPool;  
    //写入hbase任务线程池  
    @Resource(name = "insertHbaseExecutor")  
    private TaskToolExecutor insertHbaseExecutor;  
  
    @Autowired  
    private FtpUtil ftpUtil;  
    @Autowired  
    private SFTPUtil sftpUtil;  
    @Autowired  
    private GasBaseInfoService gasBaseInfoService;  
    @Autowired  
    private GasStationInfoService gasStationInfoService;  
    @Autowired  
    private GasAqcsService gasAqcsService;  
    @Autowired  
    private GasRealService gasRealService;  
    @Autowired  
    private GasAlarmService gasAlarmService;  
    @Autowired  
    private ReportRecordService reportRecordService;  
    @Autowired  
    private ReportConfigService reportConfigService;  
    @Autowired  
    private ConvertUtil convertUtil;  
    @Autowired  
    private OriginalFileService originalFileService;  
  
    /**  
     * 采集频率校验  
     */  
    public void colFreVer() {  
        Calendar calendar = Calendar.getInstance();  
        // 获取当前时分秒，HOUR_OF_DAY 表示24小时制  
        int currentHourOfDay = calendar.get(Calendar.HOUR_OF_DAY);  
        int currentMinute = calendar.get(Calendar.MINUTE);  
        int currentSecond = calendar.get(Calendar.SECOND);  
        if (currentHourOfDay == 0 && currentMinute == 0 && currentSecond == 0) {  
            // 这是00:00:00，校验 AQCS 的频率  
            colFreVerSub(FileType.AQCS_DB14);  
            // 校验 RYCS 的频率  
            colFreVerSub(FileType.RYCS_DB14);  
        }  
        if (currentMinute % 5 == 0 && currentSecond == 0) {  
            // 这是每5分钟校验一次，校验 AQMT 的频率  
            colFreVerSub(FileType.AQMT_DB14);  
            colFreVerSub(FileType.RYWZ_DB14);  
            colFreVerSub(FileType.RYTJ_DB14);  
        }  
    }  
  
    private void colFreVerSub(FileType aqcsDb14) {  
        ReportConfigEntity reportConfigEntity = reportConfigService.getOne(  
                new QueryWrapper<ReportConfigEntity>()  
                        .eq("file_type", aqcsDb14.getCode())  
                        .eq("open_remind", 0)  
        );  
        if (reportConfigEntity != null && reportConfigEntity.getCollectedCountNumber() >= 5) {  
            String message = "";  
            if (reportConfigEntity.getCollectedLastSentTime() == null) {  
                message = DingTalkUtil.DING_TALK_PREFIX  
                        + System.getProperty("line.separator")  
                        + mineName  
                        + "，" + aqcsDb14.getName() + "文件生成过快";  
            } else {  
                // 上次上报时间距离现在多少秒了  
                long l = DateUtil.pastSeconds(new Date()) - DateUtil.pastSeconds(reportConfigEntity.getCollectedLastSentTime());  
                // 允许断传的时长（秒）  
                long ll = 30 * 60;  
                if (l > ll) {  
                    message = DingTalkUtil.DING_TALK_PREFIX  
                            + System.getProperty("line.separator")  
                            + mineName  
                            + "，" + aqcsDb14.getName() + "文件生成过快";  
                }  
            }  
            if (StringUtils.isNotBlank(message)) {  
                DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
                updateColFreConfig(aqcsDb14.getCode() + "", new Date(), new Date(), 0);  
            } else {  
                updateColFreConfig(aqcsDb14.getCode() + "", reportConfigEntity.getCollectedLastSentTime(), new Date(), 0);  
            }  
        }  
    }  
  
    public void excute(List<File> files) {  
  
        String absolutePath = "";  
        ArrayList<String> pathAQFZList = new ArrayList<>();  
        ArrayList<String> pathAQMCList = new ArrayList<>();  
        ArrayList<String> pathAQKCList = new ArrayList<>();  
        ArrayList<String> pathAQSSList = new ArrayList<>();  
        ArrayList<String> pathAQBJList = new ArrayList<>();  
        ArrayList<String> pathAQYCList = new ArrayList<>();  
        ArrayList<String> pathAQCSList = new ArrayList<>();  
        ArrayList<String> pathAQKJList = new ArrayList<>();  
        ArrayList<String> pathAQDQList = new ArrayList<>();  
        ArrayList<String> pathAQGXList = new ArrayList<>();  
        ArrayList<String> pathAQKDList = new ArrayList<>();  
        ArrayList<String> pathAQLJList = new ArrayList<>();  
        ArrayList<String> pathAQMTList = new ArrayList<>();  
        ArrayList<String> pathAQKYList = new ArrayList<>();  
        for (File file : files) {  
            absolutePath = file.getAbsolutePath();  
            if (absolutePath.contains("AQFZ")) {  
                pathAQFZList.add(absolutePath);  
            } else if (absolutePath.contains("AQMC")) {  
                pathAQMCList.add(absolutePath);  
            } else if (absolutePath.contains("AQKC")) {  
                pathAQKCList.add(absolutePath);  
            } else if (absolutePath.contains("AQSS")) {  
                pathAQSSList.add(absolutePath);  
            } else if (absolutePath.contains("AQBJ")) {  
                pathAQBJList.add(absolutePath);  
            } else if (absolutePath.contains("AQYC")) {  
                pathAQYCList.add(absolutePath);  
            } else if (absolutePath.contains("AQCS")) {  
                pathAQCSList.add(absolutePath);  
            } else if (absolutePath.contains("AQKJ")) {  
                pathAQKJList.add(absolutePath);  
            } else if (absolutePath.contains("AQDQ")) {  
                pathAQDQList.add(absolutePath);  
            } else if (absolutePath.contains("AQGX")) {  
                pathAQGXList.add(absolutePath);  
            } else if (absolutePath.contains("AQKD")) {  
                pathAQKDList.add(absolutePath);  
            } else if (absolutePath.contains("AQLJ")) {  
                pathAQLJList.add(absolutePath);  
            } else if (absolutePath.contains("AQMT")) {  
                pathAQMTList.add(absolutePath);  
            } else if (absolutePath.contains("AQKY")) {  
                pathAQKYList.add(absolutePath);  
            } else {  
                delFile(absolutePath);  
            }  
        }  
  
        // 处理AQFZ  
        if (pathAQFZList.size() > 0) {  
            log.error("tag-excute-01：解析AQFZ，读取到" + pathAQFZList.size() + "个AQFZ文件");  
            threadPool.execute(() -> {  
                // 获取最新的文件  
                String path = getLatestFile(pathAQFZList);  
                excuteAQFZ(path);  
            });  
        }  
        // 处理AQMC 和 AQKC        if (pathAQMCList.size() > 0 || pathAQKCList.size() > 0) {  
            log.error("tag-excute-02：解析AQMC，读取到" + pathAQMCList.size() + "个AQMC文件");  
            log.error("tag-excute-03：解析AQKC，读取到" + pathAQKCList.size() + "个AQKC文件");  
            threadPool.execute(() -> {  
                // 获取最新的文件  
                String path1 = getLatestFile(pathAQMCList);  
                String path2 = getLatestFile(pathAQKCList);  
                excuteCDDY(path1, path2);  
            });  
        }  
        // 处理 AQSS        if (pathAQSSList.size() > 0) {  
            log.error("tag-excute-04：解析 AQSS，读取到" + pathAQSSList.size() + "个 AQSS 文件");  
            // 采集频率校验 AQSS            if (pathAQSSList.size() >= 5) {  
                handleColFreAQSS();  
            }  
            threadPool.execute(() -> {  
                if (pathAQSSList.size() == 2) {  
                    //读取到两个文件，可能是文件上传频率不是30s一次  
                    checkAQSSFile(pathAQSSList);  
                    for (String path : pathAQSSList) {  
                        excuteAQSS(path);  
                    }  
                } else {  
                    // 获取最新的文件  
                    String path = getLatestFile(pathAQSSList);  
                    excuteAQSS(path);  
                }  
            });  
        }  
        // 处理 AQBJ 和 AQYC        if (true) {  
//      if(pathAQBJList.size() > 0 || pathAQYCList.size() > 0){  
            log.error("tag-excute-05：解析 AQBJ，读取到" + pathAQBJList.size() + "个 AQBJ 文件");  
            log.error("tag-excute-06：解析 AQYC，读取到" + pathAQYCList.size() + "个 AQYC 文件");  
            threadPool.execute(() -> {  
                // 排序，按照名字asc，分别处理每一个文件，防止漏掉  
                Collections.sort(pathAQBJList);  
                Collections.sort(pathAQYCList);  
                excuteYCBJ(pathAQBJList, pathAQYCList);  
            });  
        }  
        // 处理AQCS  
        if (pathAQCSList.size() > 0) {  
            log.error("tag-excute-07：解析AQCS，读取到" + pathAQCSList.size() + "个AQCS文件");  
            // 采集频率校验 AQCS            handleColFre(FileType.AQCS_DB14, pathAQCSList.size());  
            threadPool.execute(() -> {  
                // 获取最新的文件  
                String path = getLatestFile(pathAQCSList);  
                excuteAQCS(path);  
            });  
        }  
        //处理AQKJ  
        if (CollectionUtils.isNotEmpty(pathAQKJList)) {  
            log.error("tag-excute-08：解析AQKJ，读取到" + pathAQKJList.size() + "个AQKJ文件");  
            Collections.sort(pathAQKJList);  
            excuteAQKJ(pathAQKJList);  
        }  
        //处理AQDQ  
        if (CollectionUtils.isNotEmpty(pathAQDQList)) {  
            log.error("tag-excute-09：解析AQDQ，读取到" + pathAQDQList.size() + "个AQDQ文件");  
            Collections.sort(pathAQDQList);  
            excuteAQDQ(pathAQDQList);  
        }  
        //处理AQGX  
        if (CollectionUtils.isNotEmpty(pathAQGXList)) {  
            log.error("tag-excute-10：解析AQGX，读取到" + pathAQGXList.size() + "个AQGX文件");  
            Collections.sort(pathAQGXList);  
            excuteAQGX(pathAQGXList);  
        }  
        //处理AQKD  
        if (CollectionUtils.isNotEmpty(pathAQKDList)) {  
            log.error("tag-excute-11：解析AQKD，读取到" + pathAQKDList.size() + "个AQKD文件");  
            Collections.sort(pathAQKDList);  
            excuteAQKD(pathAQKDList);  
        }  
        //处理AQLJ  
        if (CollectionUtils.isNotEmpty(pathAQLJList)) {  
            log.error("tag-excute-12：解析AQLJ，读取到" + pathAQLJList.size() + "个AQLJ文件");  
            Collections.sort(pathAQLJList);  
            excuteAQLJ(pathAQLJList);  
        }  
        //处理AQMT  
        if (CollectionUtils.isNotEmpty(pathAQMTList)) {  
            log.error("tag-excute-13：解析AQMT，读取到" + pathAQMTList.size() + "个AQMT文件");  
            // 采集频率校验 AQMT            if (pathAQMTList.size() > 0) {  
                handleColFre(FileType.AQMT_DB14, pathAQMTList.size());  
            }  
            Collections.sort(pathAQMTList);  
            excuteAQMT(pathAQMTList);  
        }  
        //处理AQKY  
        if (CollectionUtils.isNotEmpty(pathAQKYList)) {  
            log.error("tag-excute-14：解析AQKY，读取到" + pathAQKYList.size() + "个AQKY文件");  
            Collections.sort(pathAQKYList);  
            excuteAQKY(pathAQKYList);  
        }  
    }  
  
    private void excuteAQFZ(String path) {  
        try {  
            //XML解析  
            Aqfz aqfzData = SaxParser.paserXml(path, Aqfz.class);  
            List<GasStationInfoEntity> list = gasStationInfoService.saveGasStationXml(aqfzData);  
            String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQFZ);  
            delFile(path);  
            reportYjjThreadPool.execute(() -> {  
                // 分站数据上报应急管理局  
                if (reportSjOrYj.contains("0")) {  
                    try {  
                        log.error("tag-excuteAQFZ-01：解析到最新的AQFZ文件中，有" + list.size() + "条数据");  
                        writeFileToYj(ConvertUtil.FZXX, convertUtil.convFZXXxml(list));  
                    } catch (Exception e) {  
                        e.printStackTrace();  
                        RepRecordUtil.addRecord(ConvertUtil.FZXX, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
                    }  
                }  
            });  
            reportSjThreadPool.execute(() -> {  
                //上报省局  
                if (reportSjOrYj.contains("1")) {  
                    //文件内容校验  
                    try {  
                        XmlFileValidUtil.aqfzValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-01上报省局AQFZ文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQFZ);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQFZ_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-01上报AQFZ失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        } catch (Exception e) {  
            log.error("tag-excuteAQFZ-01：解析AQFZ失败", e.getMessage());  
            e.printStackTrace();  
            RepRecordUtil.addRecord(ConvertUtil.FZXX, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
  
        }  
    }  
  
    private void excuteCDDY(String path1, String path2) {  
  
        Aqmc aqmcData = null;  
        Aqkc aqkcData = null;  
        // 只有模拟量有数据，只更新数据库里的模拟量  
        if (!"".equals(path1)) {  
            //XML解析  
            try {  
                aqmcData = SaxParser.paserXml(path1, Aqmc.class);  
            } catch (Exception e) {  
                log.error("tag-excuteCDDY-02：解析AQMC-失败", e.getMessage());  
            }  
        }  
        // 只有开关量有数据  
        if (!"".equals(path2)) {  
            //XML解析  
            try {  
                aqkcData = SaxParser.paserXml(path2, Aqkc.class);  
            } catch (Exception e) {  
                log.error("tag-excuteCDDY-03：解析AQKC-失败", e.getMessage());  
            }  
        }  
        gasBaseInfoService.insertBaseInfoXml(aqmcData, aqkcData);  
        String sjTempAqmc = copyFileToSjTemp(path1, XmlFileValidUtil.AQMC);  
        delFile(path1);  
        String sjTempAqkc = copyFileToSjTemp(path2, XmlFileValidUtil.AQKC);  
        delFile(path2);  
        try {  
            reportYjjThreadPool.execute(() -> {  
  
                if (reportSjOrYj.contains("0")) {  
                    try {  
                        Thread.sleep(300);  
                    } catch (InterruptedException e) {  
                        log.error("tag-excuteCDDY-03：线程休眠异常" + e.getMessage());  
                    }  
                    log.error("tag-excuteCDDY-03：上报CDDY文件");  
                    // 重新获取模拟量  
                    List<GasBaseInfoEntity> mcList =  
                            gasBaseInfoService.list(  
                                    new QueryWrapper<GasBaseInfoEntity>().eq("sensor_type_code", "0")  
                            );  
                    // 只取最新的模拟量数据  
                    String maxMcCreateTime = mcList.stream()  
                            .map(GasBaseInfoEntity::getCreateTime)  
                            .max(Comparator.naturalOrder()).orElse(null);  
                    if (StringUtils.isNotEmpty(maxMcCreateTime)) {  
                        mcList = mcList.stream().filter(item -> maxMcCreateTime.equals(item.getCreateTime())).collect(Collectors.toList());  
                    }  
                    // 重新获取开关量  
                    List<GasBaseInfoEntity> kcList =  
                            gasBaseInfoService.list(  
                                    new QueryWrapper<GasBaseInfoEntity>().eq("sensor_type_code", "1")  
                            );  
                    // 只取最新的开关量数据  
                    String maxKcCreateTime = kcList.stream()  
                            .map(GasBaseInfoEntity::getCreateTime)  
                            .max(Comparator.naturalOrder()).orElse(null);  
                    if (StringUtils.isNotEmpty(maxKcCreateTime)) {  
                        kcList = kcList.stream().filter(item -> maxKcCreateTime.equals(item.getCreateTime())).collect(Collectors.toList());  
                    }  
                    // 模拟量, 开关量放入缓存  
                    SensorCache.putAqssCacheXml(mcList, kcList);  
                    List<String> datas = convertUtil.convCDDYXml(mcList, kcList, "yjj");  
                    // 上报应急局  
                    try {  
                        writeFileToYj(ConvertUtil.CDDY, datas);  
                        log.error("tag-excuteCDDY-06：上报CDDY文件至应急局成功");  
                    } catch (Exception e) {  
                        log.error("tag-excuteCDDY-04：上报CDDY文件至应急局失败");  
                        e.printStackTrace();  
                        RepRecordUtil.addRecord(ConvertUtil.CDDY, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
                    }  
                }  
            });  
            reportSjThreadPool.execute(() -> {  
                // 上报省煤监  
                if (reportSjOrYj.indexOf("1") > -1) {  
                    //文件内容校验  
                    try {  
                        XmlFileValidUtil.aqmcValid(sjTempAqmc);  
                    } catch (Exception e) {  
                        log.error("tag-excute-02上报省局AQMC文件校验失败：" + sjTempAqmc + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempAqmc, XmlFileValidUtil.AQMC);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQMC_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-02上报AQMC失败：" + e.getMessage());  
                    }  
  
                    //文件内容校验  
                    try {  
                        XmlFileValidUtil.aqkcValid(sjTempAqkc);  
                    } catch (Exception e) {  
                        log.error("tag-excute-03上报省局AQKC文件校验失败：" + sjTempAqkc + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempAqkc, XmlFileValidUtil.AQKC);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQKC_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-03上报省局AQKC失败：" + e.getMessage());  
                    }  
  
                }  
            });  
        } catch (Exception e) {  
            log.error("tag-excuteCDDY-07：上报CDDY文件至 应急局 / 省煤监 失败");  
            e.printStackTrace();  
        }  
    }  
  
    /**  
     * @param path  
     * @author zjb  
     */    private void excuteAQSS(String path) {  
        try {  
            log.error("tag-excuteAQSS");  
            // 记录瓦斯实时接收到的文件名称  
            recordOriginalFile(path);  
            // XML解析  
            Aqss aqssData = SaxParser.paserXml(path, Aqss.class);  
            // 入库  
            List<GasRealEntity> list = gasRealService.saveAQSSXml(aqssData);  
            String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQSS);  
            delFile(path);  
            log.error("tag-excuteAQSS-01：解析到最新的 AQSS 文件中，有" + list.size() + "条数据");  
            List<String> datas = convertUtil.convSSSJXml(list);  
            // 上报  
            reportYjjThreadPool.execute(() -> {  
                if (reportSjOrYj.contains("0")) {  
                    // 上报应急局  
                    try {  
                        writeFileToYj(ConvertUtil.SSSJ, datas);  
                        log.error("tag-excuteAQSS-02：上报 SSSJ 文件至应急局成功");  
                    } catch (Exception e) {  
                        log.error("tag-excuteAQSS-02：上报 SSSJ 文件至应急局失败");  
                        e.printStackTrace();  
                        RepRecordUtil.addRecord(ConvertUtil.SSSJ, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
                    }  
                }  
            });  
            reportSjThreadPool.execute(() -> {  
                if (reportSjOrYj.indexOf("1") > -1) {  
                    try {  
                        XmlFileValidUtil.aqssValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-04上报省局AQSS文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQSS);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQSS_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-04上报AQSS失败：" + e.getMessage());  
                    }  
                    log.error("tag-excuteAQSS-04：上报 AQSS 文件至 省煤监 成功");  
                }  
            });  
            // 写入 hbase            insertHbaseExecutor.execute(() -> {  
                try {  
                    insertRealForHbaseXml(list);  
                    log.error("tag-excuteAQSS-05：写入 hbase 成功");  
                } catch (Exception e) {  
                    log.error("tag-excuteAQSS-05：写入 hbase 失败：" + e.getMessage());  
                }  
            });  
        } catch (Exception e) {  
            log.error("tag-excuteAQSS-07：解析 AQSS 失败", e.getMessage());  
            e.printStackTrace();  
        }  
    }  
  
    private void excuteYCBJ(ArrayList<String> pathAQBJList, ArrayList<String> pathAQYCList) {  
        ArrayList<String> sjTempPathAQBJList = new ArrayList<>();  
        ArrayList<String> sjTempPathAQYCList = new ArrayList<>();  
        // 存数据库  
        for (String path : pathAQBJList) {  
            try {  
                //XML解析  
                Aqbj aqbjData = SaxParser.paserXml(path, Aqbj.class);  
                gasAlarmService.saveAQBJXml(aqbjData);  
                sjTempPathAQBJList.add(copyFileToSjTemp(path, XmlFileValidUtil.AQBJ));  
                delFile(path);  
            } catch (Exception e) {  
                log.error("tag-excuteYCBJ-01：解析 AQBJ 失败", e.getMessage());  
                e.printStackTrace();  
  
            }  
        }  
        // 存数据库  
        for (String path : pathAQYCList) {  
            try {  
                //XML解析  
                Aqyc aqycData = SaxParser.paserXml(path, Aqyc.class);  
                gasAlarmService.saveAQYCXml(aqycData);  
                sjTempPathAQYCList.add(copyFileToSjTemp(path, XmlFileValidUtil.AQYC));  
                delFile(path);  
            } catch (Exception e) {  
                log.error("tag-excuteYCBJ-02：解析 AQYC 失败", e.getMessage());  
                e.printStackTrace();  
  
            }  
        }  
  
        try {  
            // 获取所有传感器信息  
            List<GasBaseInfoEntity> gbiList = gasBaseInfoService.list();  
            // 封装成map  
            Map<String, GasBaseInfoEntity> gbiMap = new HashMap<>();  
            for (GasBaseInfoEntity o : gbiList) {  
                gbiMap.put(o.getSensorCode(), o);  
            }  
            List<GasAlarmEntity> gaeList = gasAlarmService.getYCBJXmlList();  
            // 有报警数据再上传  
            if (gaeList.size() > 0) {  
                List<String> datas = convertUtil.convYCBJxml(gaeList, gbiMap);  
                reportYjjThreadPool.execute(() -> {  
                    if (reportSjOrYj.contains("0")) {  
                        // 上报应急局  
                        try {  
                            writeFileToYj(ConvertUtil.YCBJ, datas);  
                            log.error("tag-excuteYCBJ-03：上报 YCBJ 文件至应急局成功");  
                        } catch (Exception e) {  
                            log.error("tag-excuteYCBJ-03：上报 YCBJ 文件至应急局失败");  
                            e.printStackTrace();  
                            RepRecordUtil.addRecord(ConvertUtil.YCBJ, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
                        }  
                    }  
                });  
                reportSjThreadPool.execute(() -> {  
                    //上报省局  
                    if (reportSjOrYj.indexOf("1") > -1) {  
                        //文件内容校验  
                        for (String sjTempPathAQBJ : sjTempPathAQBJList) {  
                            try {  
                                XmlFileValidUtil.aqbjValid(sjTempPathAQBJ);  
                            } catch (Exception e) {  
                                log.error("tag-excute-05上报省局AQBJ文件校验失败：" + sjTempPathAQBJ + e.getMessage());  
                            }  
                            try {  
                                reportDB14FileToSj(sjTempPathAQBJ, XmlFileValidUtil.AQBJ);  
                                //上报成功更新上报配置表  
                                reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                        .eq("file_type", FileType.AQBJ_DB14.getCode()));  
                            } catch (Exception e) {  
                                log.error("tag-excute-05上报AQBJ失败：" + e.getMessage());  
                            }  
                        }  
                        for (String sjTempPathAQYC : sjTempPathAQYCList) {  
                            try {  
                                XmlFileValidUtil.aqycValid(sjTempPathAQYC);  
                            } catch (Exception e) {  
                                log.error("tag-excute-06上报省局AQYC文件校验失败：" + sjTempPathAQYC + e.getMessage());  
                            }  
                            try {  
                                reportDB14FileToSj(sjTempPathAQYC, XmlFileValidUtil.AQYC);  
                                //上报成功更新上报配置表  
                                reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                        .eq("file_type", FileType.AQYC_DB14.getCode()));  
                            } catch (Exception e) {  
                                log.error("tag-excute-06上报AQYC失败：" + e.getMessage());  
                            }  
                        }  
                    }  
                });  
            }  
        } catch (Exception e) {  
            log.error("tag-excuteYCBJ-06：上报 YCBJ 文件至 应急局 / 省煤监 失败");  
            e.printStackTrace();  
        }  
  
  
    }  
  
    private void excuteAQCS(String path) {  
        if (reportSjOrYj.contains("1")) {  
            try {  
                //XML解析  
                Aqcs aqcsData = SaxParser.paserXml(path, Aqcs.class);  
                List<GasAqcsEntity> list = gasAqcsService.saveGasAqcsXml(aqcsData);  
                delFile(path);  
  
                reportAQCS(list);  
                //上报成功更新上报配置表  
                reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                        .eq("file_type", FileType.AQCS_DB14.getCode()));  
            } catch (Exception e) {  
                log.error("tag-excuteAQCS-01：解析AQCS失败", e.getMessage());  
                e.printStackTrace();  
                RepRecordUtil.addRecord(ConvertUtil.AQCS, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "1");  
            }  
        }  
    }  
  
    private void excuteAQKJ(ArrayList<String> pathAQKJList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQKJList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQKJ);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqkjValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-08上报省局AQKJ文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQKJ);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQKJ_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-08上报AQKJ失败：" + e.getMessage());  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQDQ(ArrayList<String> pathAQDQList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQDQList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQDQ);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqdqValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-09上报省局AQDQ文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQDQ);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQDQ_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-09上报AQDQ失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQGX(ArrayList<String> pathAQGXList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQGXList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQGX);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqgxValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-10上报省局AQGX文件校验失败：" + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQGX);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQGX_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-10上报AQGX失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQKD(ArrayList<String> pathAQKDList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQKDList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQKD);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqkdValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-11上报省局AQKD文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQKD);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQKD_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-11上报AQKD失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQLJ(ArrayList<String> pathAQLJList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQLJList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQLJ);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqljValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-12上报省局AQLJ文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQLJ);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQLJ_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-12上报AQLJ失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQMT(ArrayList<String> pathAQMTList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQMTList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQMT);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqmtValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-13上报省局AQMT文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQMT);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQMT_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-13上报AQMT失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    private void excuteAQKY(ArrayList<String> pathAQKYList) {  
        if (reportSjOrYj.contains("1")) {  
            reportSjThreadPool.execute(() -> {  
                for (String path : pathAQKYList) {  
                    //复制到省局目录  
                    String sjTempPath = copyFileToSjTemp(path, XmlFileValidUtil.AQKY);  
                    delFile(path);  
                    try {  
                        XmlFileValidUtil.aqkyValid(sjTempPath);  
                    } catch (Exception e) {  
                        log.error("tag-excute-14上报省局AQKY文件校验失败：" + sjTempPath + e.getMessage());  
                    }  
                    try {  
                        reportDB14FileToSj(sjTempPath, XmlFileValidUtil.AQKY);  
                        //上报成功更新上报配置表  
                        reportConfigService.update(new UpdateWrapper<ReportConfigEntity>().set("last_report_time", new Date()).set("last_status", 0)  
                                .eq("file_type", FileType.AQKY_DB14.getCode()));  
                    } catch (Exception e) {  
                        log.error("tag-excute-14上报AQKY失败：" + e.getMessage());  
//                    throw new RuntimeException(e);  
                    }  
                }  
            });  
        }  
    }  
  
    public void cronAQCS() {  
        List<GasAqcsEntity> list = gasAqcsService.list();  
        if (list.size() > 0) {  
            list.get(0).setDataTime(new Date());  
        }  
        reportAQCS(list);  
    }  
  
    private void reportAQCS(List<GasAqcsEntity> list) {  
        // 上报省煤监局  
        if (reportSjOrYj.indexOf("1") > -1 && list.size() > 0) {  
            reportSjThreadPool.execute(() -> {  
                try {  
                    log.error("tag-reportAQCS-01：解析到最新的AQCS文件中，有" + list.size() + "条数据");  
                    Document document = convertUtil.convFZXXDocument(list);  
                    GasAqcsEntity o = list.get(0);  
                    String fileName = o.getMineCode()  
                            + "AQCS"  
                            + DateUtil.formatDate("yyyyMMddHHmmss", o.getDataTime())  
                            + ".xml";  
                    writeDB14File(document, fileName);  
  
  
                } catch (Exception e) {  
                    e.printStackTrace();  
                    RepRecordUtil.addRecord(ConvertUtil.AQCS, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "1");  
                    // 发钉钉  
//                    toDingTalk(mineName, "AQCS", RecordErrMsg.DATA_PICK_ERR, "张军波");  
                    String message = DingTalkUtil.DING_TALK_PREFIX + System.getProperty("line.separator") + mineName + "，" + RecordErrMsg.DATA_PICK_ERR;  
                    DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
                }  
            });  
        } else {  
            // 发钉钉  
//            toDingTalk(mineName, "AQCS", "原始文件数据为空", "张军波");  
            String message = DingTalkUtil.DING_TALK_PREFIX + System.getProperty("line.separator") + mineName + "，原始文件数据为空";  
            DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
        }  
    }  
  
    /**  
     * 发钉钉  
     * Alert: 小峪 AQCS异常 原始文件数据为空 @张军波 请及时排查  
     */  
    /*private void toDingTalk(String mineName, String type, String message, String who){  
        String doJson = "{\"msgtype\": \"text\",\"text\": {\"content\": \"Alert: " + mineName + " " + type + "异常 " + message + " @"+ who +" 请及时排查\"}}";  
        try{            doPostJson(url, doJson);        }        catch(Exception e){            e.printStackTrace();        }    }*/    private void insertRealForHbaseXml(List<GasRealEntity> gasRealEntityList) throws Exception {  
  
        Map<String, List<HBaseNormalModel>> modelMap = new HashMap<>();  
        for (GasRealEntity o : gasRealEntityList) {  
            // HBase row key，测点编号_数据时间  
            String str2Long = o.getFileUpdateTime().getTime() + "";  
            String rowKey = o.getSensorCode() + "_" + str2Long;  
  
            List<HBaseNormalModel> modelList = new ArrayList<>();  
            //实时数据  
            HBaseNormalModel realData = new HBaseNormalModel();  
            realData.setCf("realdata");  
            realData.setColumn("realdata");  
            realData.setValue(o.getSensorValue());  
            // 状态  
            HBaseNormalModel status = new HBaseNormalModel();  
            status.setCf("status");  
            status.setColumn("status");  
            status.setValue(o.getSensorStatus());  
            modelList.add(realData);  
            modelList.add(status);  
  
            modelMap.put(rowKey, modelList);  
        }  
        HBaseUtils.getInstance().insertBatch(tableName, modelMap);  
    }  
  
    /**  
     * 校验AQSS文件生成时间是否为30秒一次  
     *  
     * @param list  
     */  
    private static void checkAQSSFile(List<String> list) {  
        try {  
            Collections.sort(list);  
            String onePath = list.get(0);  
            String twoPath = list.get(1);  
            File one = new File(onePath);  
            File two = new File(twoPath);  
            String oneName = one.getName();  
            String twoName = two.getName();  
            String oneNameTime = oneName.substring(oneName.indexOf("AQSS") + 4, oneName.indexOf("."));  
            Date oneNameDate = DateUtil.str2Date("yyyyMMddHHmmss", oneNameTime);  
            String twoNameTime = twoName.substring(oneName.indexOf("AQSS") + 4, oneName.indexOf("."));  
            Date twoNameDate = DateUtil.str2Date("yyyyMMddHHmmss", twoNameTime);  
            long interval = (twoNameDate.getTime() - oneNameDate.getTime()) / 1000;  
            if (interval > 25 && interval < 35) {  
                //误差时间在正负5秒，两个文件的生成时间是30s的频率  
                Date date = new Date();  
                date.setTime(one.lastModified());  
                log.error(oneName + "文件上传时间为" + DateUtil.formatDateTime(date));  
                date.setTime(two.lastModified());  
                log.error(twoName + "文件上传时间为" + DateUtil.formatDateTime(date));  
            } else {  
                //两个文件的生成时间不是30s的间隔，只保留最新的文件进行上传  
                list.remove(0);  
            }  
        } catch (Exception e) {  
            log.error("AQSS文件生成时间校验错误：" + e.getMessage());  
        }  
    }  
  
    /**  
     * 获取同一类型文件的最新一个文件  
     *  
     * @param list  
     * @return  
     */    private String getLatestFile(ArrayList<String> list) {  
  
        if (list.size() == 0) {  
            return "";  
        }  
        String max = list.get(0);  
        for (int i = 0; i < list.size(); i++) {  
            if (max.compareTo(list.get(i)) < 0) {  
                delFile(max);  
                max = list.get(i);  
            } else {  
                //删除文件  
                if (i > 0) {  
                    delFile(list.get(i));  
                }  
            }  
        }  
        return max;  
    }  
  
    /**  
     * 清理文件  
     */  
    private void delFile(String fileName) {  
  
        if (StringUtils.isBlank(fileName)) {  
            return;  
        }  
        try {  
            File file = new File(fileName);  
            if (file.exists()) {  
                log.error("tag-delFile-01：" + fileName + "文件删除：" + file.delete());  
            }  
        } catch (Exception e) {  
            log.error("tag-delFile-02：" + "文件删除失败：" + e.getMessage());  
        }  
    }  
  
    /**  
     * 检查文件是否存在  
     */  
    private boolean checkFile(String fileName) {  
        File file = new File(fileName);  
        boolean exists = file.exists();  
        if (!exists) {  
            log.error("文件不存在：" + fileName);  
        }  
        return exists;  
    }  
  
    /**  
     * 将上报数据写入文件  
     *  
     * @param fileType 文件分类  
     * @param datas    数据列表  
     */  
    public void writeFile(String fileType, List<String> datas) {  
        // 添加文件结尾标志 ||        datas.add(datas.remove(datas.size() - 1) + ConvertUtil.END_SUFFIX);  
        // 生成文件（文件名称按格式）  结尾YJ表示文件属于上传至应急管理局的  
        String fileName = mineCode + fileType + DateUtil.getDate("yyyyMMddHHmmss") + ".TXT";  
        // 先写到本地文件，留作备份  
        String path = Constant.UPLOAD_TEMP + File.separator + DateUtil.getDate();  
        File dir = new File(path);  
        if (!dir.exists()) {  
            dir.mkdirs();  
        }  
        File target = new File(path + File.separator + fileName);  
        try {  
            // 写入到文件  
            FileUtils.writeLines(target, "UTF-8", datas);  
        } catch (IOException e) {  
            log.error("tag-writeFile-01：文件" + fileType + "写入数据失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "1");  
            return;  
        }  
        try {  
            // 上传到FTP服务器  
            FileInputStream inputStream = FileUtils.openInputStream(target);  
            boolean upload = ftpUtil.upload(ftpUtil.getReportDir() + "/" + fileName, inputStream);  
            IOUtils.closeQuietly(inputStream);  
            if (upload) {  
                RepRecordUtil.addRecord(fileName, true, " ", "1");  
                log.error("tag-writeFile-02：文件" + fileName + "上传到省煤监FTP成功");  
                target.delete();  
            } else {  
                RepRecordUtil.addRecord(fileName, false, RecordErrMsg.FTP_CONNECT_ERR, "1");  
            }  
        } catch (Exception e) {  
            log.error("tag-writeFile-03：文件" + fileName + "上传到省煤监FTP失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, RecordErrMsg.FTP_CONNECT_ERR + ":" + e.getMessage(), "1");  
        }  
    }  
  
    /**  
     * 将上报数据写入文件-上传至应急管理局  
     *  
     * @param fileType 文件分类  
     * @param datas    数据列表  
     */  
    public void writeFileToYj(String fileType, List<String> datas) {  
        // 添加文件结尾标志 ||        datas.add(datas.remove(datas.size() - 1) + ConvertUtil.END_SUFFIX);  
        // 生成文件（文件名称按格式）  
        String fileName = mineCode + fileType + DateUtil.getDate("yyyyMMddHHmmss") + ".TXT";  
        // 先写到本地文件，留作备份  
        String path = Constant.UPLOAD_TEMP + File.separator + DateUtil.getDate();  
        File dir = new File(path);  
        if (!dir.exists()) {  
            dir.mkdirs();  
        }  
        File target = new File(path + File.separator + fileName);  
        try {  
            // 写入到文件  
            FileUtils.writeLines(target, "UTF-8", datas);  
        } catch (IOException e) {  
            log.error("tag-writeFileToYj-01：文件" + fileType + "写入数据失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, RecordErrMsg.DATA_PICK_ERR + ":" + e.getMessage(), "0");  
            return;  
        }  
        try {  
            // 上传SFTP  
            FileInputStream inputStream = FileUtils.openInputStream(target);  
            sftpUtil.upload(inputStream, ftpUtil.getYjSFTPReportDir() + "/" + fileName);  
            IOUtils.closeQuietly(inputStream);  
            RepRecordUtil.addRecord(fileName, true, " ", "0");  
            log.error("tag-writeFileToYj-02：文件" + fileName + "上传到应急管理局SFTP成功");  
            // 临时增加备份文件  
            if (ConvertUtil.SSSJ.equals(fileType)){  
                FileCopyTemp(target.getPath(), fileName);  
            }  
            //文件上传成功则删除本地文件  
            target.delete();  
  
        } catch (Exception e) {  
            log.error("tag-writeFileToYj-03：文件" + fileName + "上传到应急管理局FTP失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, RecordErrMsg.FTP_CONNECT_ERR + ":" + e.getMessage(), "0");  
        }  
    }  
  
    private void FileCopyTemp(String filePath,  String fileName) {  
        FileInputStream inStream = null; // 创建输入流  
        FileOutputStream outStream = null; // 创建输出流  
  
        try {  
            // 读取源文件  
            File sourceFile = new File(filePath); // 源文件  
            inStream = new FileInputStream(sourceFile); // 通过源文件创建输入流  
  
            // 写入目标文件  
            String targetFilePath = "upload/backupYJJ/" + DateUtil.getDate();  
            File dir = new File(targetFilePath);  
            if (!dir.exists()) {  
                dir.mkdirs();  
            }  
            String targetFileName = targetFilePath + File.separator + fileName;  
            File targetFile = new File(targetFileName); // 目标文件  
            outStream = new FileOutputStream(targetFile); // 通过目标文件创建输出流  
  
            byte[] buffer = new byte[1024]; // 创建缓冲区  
            int length; // 用于记录每次读取的字节数  
            while ((length = inStream.read(buffer)) > 0) {  
                outStream.write(buffer, 0, length); // 将缓冲区内容写入目标文件  
            }  
            log.error("tag-FileCopy-01-temo：文件" + fileName + "备份成功");  
        } catch (IOException e) {  
            e.printStackTrace();  
        } finally {  
            // 关闭输入输出流  
            try {  
                inStream.close(); // 关闭输入流  
                outStream.close(); // 关闭输出流  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
  
    /**  
     * 处理积压文件，如果有的话  
     *  
     * @param path  
     */  
    public void handleBacklog(String path) {  
  
        File file0 = new File(path);  
        String[] fileName0 = file0.list();  
  
        // SSSJ 是否有积压，0无，1有  
        int isBackLogSSSJ = 0;  
        for (String s : fileName0) {  
            if (s.contains("SSSJ")) {  
                isBackLogSSSJ++;  
                break;  
            }  
        }  
        // isBackLogSSSJ > 0, 说明一定有积压，要不然此时的 SSSJ 明明已经上报了，为什么还会有SSSJ  
        if (isBackLogSSSJ > 0) {  
            int allSize0 = fileName0.length;  
            try {  
                Thread.sleep(3000);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            // 过3s，再看一下积压文件总数是否发生变化  
            File file1 = new File(path);  
            String[] fileName1 = file1.list();  
            // 再次获取 allSize            int allSize1 = fileName1.length;  
            if (allSize0 == allSize1) {  
                // 开始处理积压文件  
                // 顺序为：FZXX, CDDY, YCBJ, SSSJ  
                List<String> pathFZXXList = new ArrayList<>();  
                List<String> pathCDDYList = new ArrayList<>();  
                List<String> pathYCBJList = new ArrayList<>();  
                List<String> pathSSSJList = new ArrayList<>();  
                for (String s : fileName1) {  
                    if (s.contains("FZXX")) {  
                        pathFZXXList.add(s);  
                    } else if (s.contains("CDDY")) {  
                        pathCDDYList.add(s);  
                    } else if (s.contains("YCBJ")) {  
                        pathYCBJList.add(s);  
                    } else if (s.contains("SSSJ")) {  
                        pathSSSJList.add(s);  
                    }  
                }  
                Collections.sort(pathFZXXList);  
                Collections.sort(pathCDDYList);  
                Collections.sort(pathYCBJList);  
                Collections.sort(pathSSSJList);  
  
                for (String s : pathFZXXList) {  
                    uploadPlusToYjj(path, s);  
                }  
                for (String s : pathCDDYList) {  
                    uploadPlusToYjj(path, s);  
                }  
                for (String s : pathYCBJList) {  
                    uploadPlusToYjj(path, s);  
                }  
                for (String s : pathSSSJList) {  
                    uploadPlusToYjj(path, s);  
                }  
            } else {  
                // 两次allSize不相等，说明，这3s的时间，又有文件上报了，temp文件夹里的文件减少了  
                // 原因是，可能是刚来网的时候，刚好又上报了FZXX,CDDY,YCBJ（这种可能性比较小）  
                // 也可能是上一个处理积压的 SSSJ 线程，正在处理积压的文件，30s都没有处理完，此时此刻还在处理  
                // 不做任何操作  
            }  
        }  
    }  
  
    /**  
     * 补传文件，至应急局  
     *  
     * @param path  
     * @param fileName  
     */  
    private void uploadPlusToYjj(String path, String fileName) {  
  
        File target = new File(path + File.separator + fileName);  
        try {  
            FileInputStream inputStream = FileUtils.openInputStream(target);  
            sftpUtil.upload(inputStream, ftpUtil.getYjSFTPReportDir() + "/" + fileName);  
            IOUtils.closeQuietly(inputStream);  
            RepRecordUtil.addRecord(fileName, true, "补传", "0");  
            log.error("补传文件" + fileName + "到应急管理局成功");  
            target.delete();  
        } catch (Exception e) {  
            log.error("补传文件" + fileName + "到应急管理局失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, "补传失败，" + RecordErrMsg.FTP_CONNECT_ERR + ":" + e.getMessage(), "0");  
        }  
    }  
  
    public void writeDB14File(Document document, String fileName) {  
  
        // 先写到本地文件，留作备份  
        String path = Constant.UPLOAD_TEMP + File.separator + DateUtil.getDate();  
        File dir = new File(path);  
        if (!dir.exists()) {  
            dir.mkdirs();  
        }  
  
        String filePath = path + File.separator + fileName;  
        OutputFormat format = OutputFormat.createPrettyPrint();  
        XMLWriter writer;  
        try {  
            writer = new XMLWriter(new FileWriter(filePath), format);  
            writer.write(document);  
            writer.close();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
  
        File target = new File(filePath);  
        try {  
            // 上传到FTP服务器  
            FileInputStream inputStream = FileUtils.openInputStream(target);  
            boolean upload = ftpUtil.upload(ftpUtil.getReportDir() + "/" + fileName, inputStream);  
            IOUtils.closeQuietly(inputStream);  
            if (upload) {  
                RepRecordUtil.addRecord(fileName, true, " ", "1");  
                log.error("tag-writeDB14File-01：文件" + fileName + "上传到省煤监FTP成功");  
                FileCopy(filePath, fileName);  
                target.delete();  
            } else {  
                RepRecordUtil.addRecord(fileName, false, RecordErrMsg.FTP_CONNECT_ERR, "1");  
            }  
        } catch (Exception e) {  
            log.error("tag-writeDB14File-02：文件" + fileName + "上传到省煤监FTP失败：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, false, RecordErrMsg.FTP_CONNECT_ERR + ":" + e.getMessage(), "1");  
        }  
    }  
  
    private void FileCopy(String filePath, String fileName) {  
        FileInputStream inStream = null; // 创建输入流  
        FileOutputStream outStream = null; // 创建输出流  
  
        try {  
            // 读取源文件  
            File sourceFile = new File(filePath); // 源文件  
            inStream = new FileInputStream(sourceFile); // 通过源文件创建输入流  
  
            // 写入目标文件  
            String targetFilePath = "upload/backup/" + DateUtil.getDate();  
            File dir = new File(targetFilePath);  
            if (!dir.exists()) {  
                dir.mkdirs();  
            }  
            String targetFileName = targetFilePath + File.separator + fileName;  
            File targetFile = new File(targetFileName); // 目标文件  
            outStream = new FileOutputStream(targetFile); // 通过目标文件创建输出流  
  
            byte[] buffer = new byte[1024]; // 创建缓冲区  
            int length; // 用于记录每次读取的字节数  
            while ((length = inStream.read(buffer)) > 0) {  
                outStream.write(buffer, 0, length); // 将缓冲区内容写入目标文件  
            }  
            log.error("tag-FileCopy-01：文件" + fileName + "备份成功");  
            // 备份路径回写到 report_record 表，更新 file_path，file_source 这两个字段  
            writeBackPathToRecord(fileName);  
        } catch (IOException e) {  
            e.printStackTrace();  
        } finally {  
            // 关闭输入输出流  
            try {  
                inStream.close(); // 关闭输入流  
                outStream.close(); // 关闭输出流  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
  
    /**  
     * 备份路径回写到 report_record 表  
     * 更新 file_path，file_source 这两个字段  
     *  
     * @param fileName  
     */  
    private void writeBackPathToRecord(String fileName) {  
  
        ReportRecordEntity record = reportRecordService.getOne(  
                new QueryWrapper<ReportRecordEntity>()  
                        .eq("target_name", fileName)  
                        .eq("source_name", "1")  
                        .eq("rep_status", "0"));  
        if (record != null) {  
            record.setFilePath("/upload/backup/" + DateUtil.getDate() + "/" + fileName);  
            record.setFileSource("AQ");  
            reportRecordService.updateById(record);  
        }  
    }  
  
    public void checkFrequency() {  
  
        List<ReportConfigEntity> list = reportConfigService.list(  
                new QueryWrapper<ReportConfigEntity>()  
//                        .in("file_type", "AQCS", "AQMT", "AQSS", "RYTJ", "RYWZ")  
                        .in("file_type", "19", "26", "29", "41", "42")  
                        .eq("open_remind", 0)  
        );  
  
        for (ReportConfigEntity o : list) {  
            // 从未上报过该文件  
            if (o.getLastReportTime() == null) {  
//                toDingTalk(mineName, o.getFileType(), "未上报"+ o.getFileType() +"文件", "张军波");  
                String message = DingTalkUtil.DING_TALK_PREFIX + System.getProperty("line.separator") + mineName  
                        + "，未上报" + o.getFileType() + "文件";  
                DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
            } else {  
                // 上次上报时间距离现在多少秒了  
                long l = DateUtil.pastSeconds(new Date()) - DateUtil.pastSeconds(o.getLastReportTime());  
                // 允许断传的时长（秒）  
                long ll = o.getPassOffDelay() * 60;  
                if (l > ll) {  
                    String message = DingTalkUtil.DING_TALK_PREFIX + System.getProperty("line.separator") + mineName  
                            + "，"  
                            + o.getFileType()  
                            + "文件上传中断，已断传"  
                            + DateUtil.formatSecond((int) l)  
                            + "，上次上报时间为"  
                            + DateUtil.formatDate(o.getLastReportTime());  
//                    toDingTalk(mineName, o.getFileType(), message, "张军波");  
                    DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
                }  
  
            }  
        }  
    }  
  
    /**  
     * 发钉钉  
     *  
     * @return     * @throws Exception  
     */  
    /*public static String doPostJson(String url, String params) throws Exception {        CloseableHttpClient httpclient = HttpClients.createDefault();        HttpPost httpPost = new HttpPost(url);// 创建httpPost  
        httpPost.setHeader("Accept", "application/json");        httpPost.setHeader("Content-Type", "application/json");        String charSet = "UTF-8";        StringEntity entity = new StringEntity(params, charSet);        httpPost.setEntity(entity);        CloseableHttpResponse response = null;        try {            response = httpclient.execute(httpPost);            StatusLine status = response.getStatusLine();            int state = status.getStatusCode();            if (state == HttpStatus.SC_OK) {                HttpEntity responseEntity = response.getEntity();                String jsonString = EntityUtils.toString(responseEntity);                return jsonString;            } else {//                logger.error( "请求返回:" + state + "(" + url + ")" );  
            }        } finally {            if (response != null) {                try {                    response.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            try {                httpclient.close();            } catch (IOException e) {                e.printStackTrace();            }        }        return null;    }*/    public String copyFileToSjTemp(String filePath, String fileCategory) {  
        if (StringUtils.isEmpty(filePath)) {  
            return "";  
        }  
        File file = new File(filePath);  
        if (!file.exists()) {  
            return "";  
        }  
        // 先复制到本地文件，留作备份  
        String path = Constant.UPLOAD_SJ_TEMP + File.separator + DateUtil.getDate();  
        File dir = new File(path);  
        if (!dir.exists()) {  
            dir.mkdirs();  
        }  
        File target = new File(path + File.separator + file.getName());  
        try {  
            FileUtils.copyFile(file, target);  
            XmlFileValidUtil.updateParseCheckSucDetail(fileCategory, ErrCategory.FILE_COPY_ERROR);  
            return target.getAbsolutePath();  
        } catch (IOException e) {  
            log.error("DB14瓦斯文件校验错误，" + file.getName() + "复制到校验临时目录异常：" + e.getMessage());  
            XmlFileValidUtil.updateParseCheckErrDetail(file.getName(), "DB14瓦斯文件校验错误，" + file.getName() + "复制到校验临时目录异常：" + e.getMessage(),  
                    fileCategory, ErrCategory.FILE_COPY_ERROR);  
            return "";  
        }  
    }  
  
    public void copyFileToSjTempErr(String filePath, String fileCategory) {  
        if (StringUtils.isEmpty(filePath)) {  
            return;  
        }  
        File file = new File(filePath);  
        if (!file.exists()) {  
            return;  
        }  
        // 先复制到本地文件到错误目录  
        String parentDir = file.getParentFile().getName();  
        String path = Constant.UPLOAD_SJ_TEMP + File.separator + "ftp_err" + File.separator + parentDir;  
        File dir = new File(path);  
        if (!dir.exists()) {  
            dir.mkdirs();  
        }  
        File target = new File(path + File.separator + file.getName());  
        try {  
            FileUtils.copyFile(file, target);  
            XmlFileValidUtil.updateParseCheckSucDetail(fileCategory, ErrCategory.FILE_COPY_ERROR);  
        } catch (IOException e) {  
            log.error("DB14瓦斯文件上传错误，" + file.getName() + "复制到补传临时目录异常：" + e.getMessage());  
            XmlFileValidUtil.updateParseCheckErrDetail(file.getName(), "DB14瓦斯文件上传错误，" + file.getName() + "复制到补传临时目录异常：" + e.getMessage(),  
                    fileCategory, ErrCategory.FILE_COPY_ERROR);  
        }  
    }  
  
    public void reportDB14FileToSj(String filePath, String fileCategory) {  
        if (StringUtils.isEmpty(filePath)) {  
            return;  
        }  
        File target = new File(filePath);  
        String fileName = target.getName();  
        Map<String, FileType> fileTypeMap = FileTypeUtil.fileTypeMap;  
        try {  
            // 上传到FTP服务器  
            FileInputStream inputStream = FileUtils.openInputStream(target);  
            boolean upload = ftpUtil.upload(ftpUtil.getReportDir() + "/" + fileName, inputStream);  
            IOUtils.closeQuietly(inputStream);  
            if (upload) {  
                RepRecordUtil.addRecord(fileName, fileTypeMap.get(fileCategory), true, " ", "1");  
                log.error("文件" + fileName + "上传到省煤监FTP成功");  
                FileCopy(filePath, fileName);  
                target.delete();  
                //文件上报成功  
                XmlFileValidUtil.updateParseCheckSucDetail(fileCategory, ErrCategory.FTP_UPLOAD_ERROR);  
            } else {  
                throw new GlobalException("文件上报失败，ftp上传错误");  
            }  
        } catch (Exception e) {  
            log.error("DB14瓦斯文件上传错误" + fileName + "FTP上传省煤监异常：" + e.getMessage());  
            RepRecordUtil.addRecord(fileName, fileTypeMap.get(fileCategory), false, RecordErrMsg.FTP_CONNECT_ERR + ":" + e.getMessage(), "1");  
            XmlFileValidUtil.updateParseCheckErrDetail(fileName, "DB14瓦斯文件上传错误" + fileName + "FTP上传省煤监异常：" + e.getMessage(),  
                    fileCategory, ErrCategory.FTP_UPLOAD_ERROR);  
            copyFileToSjTempErr(filePath, fileCategory);  
            target.delete();  
            throw new GlobalException("DB14瓦斯文件上传错误" + fileName + "FTP上传省煤监异常：" + e.getMessage());  
        }  
    }  
  
    private void recordOriginalFile(String path) {  
        try {  
            File file = new File(path);  
            OriginalFileEntity entity = originalFileService.getOne(new QueryWrapper<OriginalFileEntity>().eq("file_type", "AQ"));  
            if (entity == null) {  
                entity = new OriginalFileEntity();  
            }  
            entity.setFileName(file.getName());  
            entity.setFileType("AQ");  
            entity.setUpdateTime(DateUtil.getDateTime());  
            originalFileService.saveOrUpdate(entity);  
        } catch (Exception e) {  
            log.error("记录瓦斯实时接收到的文件名称失败", e);  
        }  
    }  
  
    /**  
     * AQSS 文件生成过快，处理 AQSS 文件  
     */  
    private void handleColFreAQSS() {  
        // checkColFrequency()  
        ReportConfigEntity reportConfigEntity = reportConfigService.getOne(  
                new QueryWrapper<ReportConfigEntity>()  
                        .eq("file_type", "26")  
                        .eq("open_remind", 0)  
        );  
        if (reportConfigEntity == null) {  
            return;  
        }  
  
        String message = "";  
        if (reportConfigEntity.getCollectedLastSentTime() == null) {  
            message = DingTalkUtil.DING_TALK_PREFIX  
                    + System.getProperty("line.separator")  
                    + mineName  
                    + "，AQSS文件生成过快";  
        } else {  
            // 上次上报时间距离现在多少秒了  
            long l = DateUtil.pastSeconds(new Date()) - DateUtil.pastSeconds(reportConfigEntity.getCollectedLastSentTime());  
            // 允许断传的时长（秒）  
            long ll = 30 * 60;  
            if (l > ll) {  
                message = DingTalkUtil.DING_TALK_PREFIX  
                        + System.getProperty("line.separator")  
                        + mineName  
                        + "，AQSS文件生成过快";  
            }  
        }  
        if (StringUtils.isNotBlank(message)) {  
            DingTalkUtil.sendDingTalk(dingTalkUrl, message, noticePersons);  
            // update Collection frequency Config  
            updateColFreConfig("26", new Date(), new Date(), 0);  
        }  
    }  
  
    /**  
     * AQCS等: 计数 AQCS 等文件  
     */  
    private void handleColFre(FileType fileType, Integer i) {  
        ReportConfigEntity reportConfigEntity = reportConfigService.getOne(  
                new QueryWrapper<ReportConfigEntity>()  
                        .eq("file_type", fileType.getCode() + "")  
                        .eq("open_remind", 0)  
        );  
        if (reportConfigEntity == null) {  
            return;  
        }  
        Integer collectedCountNumber = 0;  
        // 第一次过来统计  
        if (reportConfigEntity.getCollectedLastCountTime() == null) {  
            collectedCountNumber = i;  
            updateColFreConfig(fileType.getCode() + "", null, new Date(), collectedCountNumber);  
        } else {  
            collectedCountNumber = reportConfigEntity.getCollectedCountNumber() + i;  
            updateColFreConfig(fileType.getCode() + "",  
                    reportConfigEntity.getCollectedLastSentTime(),  
                    reportConfigEntity.getCollectedLastCountTime(),  
                    collectedCountNumber);  
        }  
    }  
  
    /**  
     * report_config表 信息更新  
     * update Collection frequency Config  
     *     * @param fileType  
     * @param collectedLastSentTime  
     * @param collectedLastCountTime  
     * @param collectedCountNumber  
     */  
    private void updateColFreConfig(String fileType,  
                                    Date collectedLastSentTime,  
                                    Date collectedLastCountTime,  
                                    Integer collectedCountNumber) {  
        ReportConfigEntity o = reportConfigService.getOne(  
                new QueryWrapper<ReportConfigEntity>()  
                        .eq("file_type", fileType)  
        );  
        o.setCollectedLastSentTime(collectedLastSentTime);  
        o.setCollectedLastCountTime(collectedLastCountTime);  
        o.setCollectedCountNumber(collectedCountNumber);  
        reportConfigService.updateById(o);  
    }  
}
```