


# 9、dubbo
## 9.1、dubbo和springCloud区别
两者都是现在主流的分布式框架，但却存在不少差异：

- **生态环境不同：** SpringCloud定位为微服务架构下的一站式解决方案（网关，分布式配置，服务跟踪）；Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用和治理
- **调用方式：** SpringCloud是采用Http协议做远程调用；Dubbo是基于RPC调用
- **组件差异比较多**，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper

![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1675996970042-0552f61a-26e1-402c-9dc1-642431c222ab.webp#averageHue=%23eff3f2&clientId=ued21274a-04e3-4&from=paste&id=ue20f9ce5&originHeight=341&originWidth=771&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u280d4e8b-f356-4658-9572-330db8e00f5&title=)

## 9.2、dubbo支持哪些协议
**1、dubbo 默认协议：**

- 单一 TCP 长连接，Hessian 二进制序列化和 NIO 异步通讯
- 不适合传送大数据包的服务

**2、rmi 协议：**

- 采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式
- 对传输数据包不限，消费者和传输者个数相当

**3、hessian 协议：**

- 底层 Http 通讯，Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现
- 通讯效率高于 WebService 和 Java 自带的序列化
- 适用于传输数据包较大，提供者比消费者个数多，提供者压力较大

**4、http 协议：**

- 基于 http 表单的远程调用协议，短连接，json 序列化
- 对传输数据包不限，不支持传文件

**5、webservice 协议：**

- 基于 Apache CXF 的 frontend-simple 和 transports-http 实现，短连接，SOAP文本序列化
- 可与原生 WebService 服务互操作
- 适用于系统集成、跨语言调用

**6、thrift 协议：**

- 对 thrift 原生协议 [2] 的扩展添加了额外的头信息
- 使用较少，不支持传 null 值

**7、基于 Redis实现的 RPC 协议**
**8、基于 Memcached 实现的 RPC 协议】**

## 9.3、dubbo负载均衡策略
```java
dubbo:
  provider:
    loadbalance: roundrobin
```
> 也可以在注解上进行配置
> @Service(version = "${product.service.version}",loadbalance="roundrobin")

1. RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的**默认**负载均衡策略。
2. RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。
3. LeastActiveLoadBalance: 最小活跃数负载均衡，活跃数也就是dubbo的连接数，每当收到一个请求活跃数+1，结束请求活跃数-1，假设如果多台机器的连接数是相同的，如果一台机器性能比较好，处理请求比较快那么活跃数减少的就快，活跃数就少。所以活跃数少的就会获取到的请求会变多，这样就可以合理的使用性能不同的机器了
4. ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。

## 9.4、dubbo集群容错
| **类型** | **负载均衡** | **备注** |
| --- | --- | --- |
| failover | 会 | 失败后会尝试调用其他服务器实例，默认尝试2次， 可以通过设置retries来设置次数。这是dubbo默认的容错机制，由于常常可能因为超时待原因触发异常但远程服务已经完成操作，所以这个类型不应就在数据更新的操作 |
| failfast | 会 | 有异常立即返回，不做尝试，我认为可以用在数据更新上，以保证数据的一致性 |
| fastsafe | 会 | 有异常会直接忽略，为的是保证调用方接下来的正常运行，一般用于日志收集等与正常流程无关的操作 |
| failback | 会 | 失败后会将任务丢到失败队列中，并会异步再次尝试 |
| forking | 否 | 同时调用多个服务，取最先返回的结果，可以通过forks设置最大并行数，这比较浪费资源 |
| broadcast | 否 | 调用所有可用的服务，任意一个有错都会返回异常 |
| Mock | 否 | 调用失败时返回伪造的响应结果 |

> 一般在@DubboService或@DubboReference指定cluster即可，如
@DubboService(cluster = “failover”) //默认重试2次


## 9.5、dubbo节点角色

1. Container：服务运行容器。
2. Provider：暴露服务的服务提供方。
3. Consumer：调用远程服务的服务消费方。
4. Registry：服务注册与发现的注册中心。
5. Monitor：统计服务的调用次数和调用时间的监控中心。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676255772897-ef7e967d-0649-47fc-9619-df682d81623d.png#averageHue=%23fdfdfd&clientId=u8e7e2608-ecdb-4&from=paste&height=436&id=ued12782e&originHeight=824&originWidth=1060&originalType=url&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=u97be041b-5627-4a7c-bd1d-83152ce3e7b&title=&width=561)
## 9.5、dubbo调用过程

1. 服务容器 Container 负责启动加载运行服务提供者 Provider。根据配置中的 Registry 地址连接 Registry，在 Registry 注册自己提供的服务。
2. Consumer 在启动时，根据配置文件中的服务引用信息，连接到 Registry，向 Registry 订阅自己所需的服务。
4. Registry 根据服务订阅关系，返回 Provider 地址列表给 Consumer。如果有变更，Registry 会基于长连接推送最新的服务地址信息给 Consumer。
5. Consumer 调用远程服务时，基于负载均衡算法，从缓存的 Provider 地址列表中选择一台进行跨进程调用服务
6. 服务 Provider 和 Consumer，会在内存中记录调用次数和调用时间，每分钟发送一次统计数据到 Monitor。

# 10、springCloud
## 10.1、如何保证分布式事务一致性？

1. 首先是设计方案尽可能规避分布式事务的场景（相似的业务放在一起，不要过度的拆分）
2. 根据业务场景，选择使用柔性事务（ap）还是强事务(cp)

如果可以允许消息存在一段时间不一致，只要保证最终一致性，可以用本地消息表来做。如果要保证一致性，可以用2pc，具体实现方案有阿里的seata

3. 本地消息表（柔性事务）

不去同步的调用，先将要请求的消息插入到本地的消息表中，消息状态为正在处理，起一个定时任务去查询消息表，将正在处理的消息发送到消息队列，B中消息处理完后，向一个return队列发送一个成功的消息，A订阅了该消息队列，收到成功的消息后将状态该为处理完毕。（被调用方应保证幂等性，如库存系统在减库存前先查流水表，看该订单是否扣过库存，扣过就不执行）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679844537244-b3de5d9e-7e6e-4b74-9345-cbb66fedcb80.png#averageHue=%23f5f5f5&clientId=u051b1bd0-acdc-4&from=paste&height=454&id=u41a8bcd9&originHeight=454&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131665&status=done&style=none&taskId=u5de36835-b151-439d-8526-90f53f7550e&title=&width=1389)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679845311357-39625a82-0e3e-4795-bd7e-5643f203abe8.png#averageHue=%23f0f0f0&clientId=u051b1bd0-acdc-4&from=paste&height=204&id=uf58d5a6a&originHeight=204&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38032&status=done&style=none&taskId=u4db46ad2-afb8-4c97-abaf-64c4c34f5eb&title=&width=642)

## 10.2、架构的演进
单体-垂直-分布式-SOA-微服务 （详情看springcloud笔记开头部分）

## 10.3、分布式和微服务有什么关系？
我理解的分布式是一种系统架构，指一个系统由多个独立的组件组成，这些组件可以在不同的物理位置上运行，从而提升了系统的性能
而微服务可以看作是分布式的一种实现方案。分布式实现方案有soa，基于rpc远程调用（dubbo），微服务（springcloud）

# 11、场景题
## 11.1、两个50亿url的文件如何找出共同的url
**问题：**给A，B两个文件，各存放50亿条URL，每条URL占用64个字节，内存限制为4G，找出A，B中相同的URL。

**分析：**可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法

**方案：**分治思想

1. 分治思想遍历文件A，对每个url求hash(url)%N，然后将取得的值分布到N个小文件中，每个小文件可以放在内存中。
2. 遍历文件B，采取和A相同的方式将url存储到N个小文件中.
3. 分布取两个小文件，把一个小文件加入hashset，然后遍历另一个，如果url在哈希表，则为共同url，汇总到结果中。
> 有可能出现哈希碰撞，可以采用多个哈希函数减少碰撞概率。


## 11.2、如何从1000w记录中，找出最热门的10个记录？
> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前一个日志文件中有一千万个记录 (这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过了百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门) ，请你统计最热门的1口个查询串，要求使用的内存不能超过1G


> 1000万条记录，每条记录最大为255Byte，那么日志文件最大有2.5G左右（超过1G）
> 如果去重复有100万条记录，占用250M内存。那么我们可以考虑将这些无重复的记录装入内存
> 这时我们需要一种数据结构，这种数据结构即能够存储查询串，又能存储查询串的出现次数。

    第一步、先对这批海量数据预处理，用hashmap存储，key为内容，value为出现次数 。O（N）
    第二步、创建一个长度为10的小根堆，遍历hashmap，如果MinHeap未满，那么往MinHeap中插入这个键值对，如果MinHeap满了，则比较遍历到的元素的count值堆顶的count，如果遍历到元素的count大于堆顶count值，删除堆顶元素，插入当前遍历到的元素。遍历完整个hashmap以后，在MinHeap中存储的就是最热门10个查询串

## 11.3、20亿个用户统计登录状态
> 20亿的用户，频繁改变数据库，io极大，数据库性能可能会被拖垮。
> 考虑使用redis，如果用set存储，登录存入set，退出删除。一个用户按4字节，10亿个用户4G内存，太大

我们使用redis的bitmap来进行存储。
setbit命今 语法:setbit key offset value  设置或修改key上的偏移量 (offset) 的位 (value) 的值
10亿用户，1个用户只占用1bit 相比于set占用的4字节，优化了了32倍那么节省后的内存为125MB。
优点:查找效率高。
缺点: 结果数据不能重复，数据如果太过分散会造成浪费，只有数据密集才可以

# 12、数据结构和算法
## 12.1、堆

1. 定义：堆通常可以被看做是一棵完全二叉树的数组对象
> [完全二叉树](https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020)，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求节点都靠左


2. 特点

（1）它是完全二叉树
（2）它通常用数组来实现。具体方法就是将二叉树的结点按照层级顺序放入数组中
（3）堆中树的某个结点的父结点与左右子结点对应数组的索引关系：如果一个结点的位置为k，则它的父结点的位置为k/2,而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动
（4）每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的

3. 插入与删除的实现

插入：利用上浮算法进行数据插入，上浮算法就是将待上浮的结点与其父结点比较，如果待上浮的结点大于父结点，则交换位置，循环往复，直至待上浮的结点没有父结点。因此，将待插入的结点放到数组的最后一个元素，然后将插入的结点作为待上浮的结点，通过上浮算法将其放到合适的位置。
删除：下沉算法就是通过将待下沉的结点k，与其左子结点2k和右子结点2k+1中较大的结点进行比较，如果待下沉的结点小于左子结点和右子结点中较大的结点，则交换位置，循环往复，直至待下沉的结点没有左右子结点即叶子节点时完成下沉
# 
# 13、设计模式

1. 创建型模式：创建型模式关注对象的创建过程，主要包括简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式。
2. 结构型模式：结构型模式关注对象之间的组合和协作关系，主要包括适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式。
3. 行为型模式：行为型模式关注对象之间的交互和通信，主要包括模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式和访问者模式。
## 13.1、单例模式

1. 饿汉模式：在类加载时就完成了初始化，但是加载比较慢，获取对象比较快
```java
public class Singleton_hungry {
    //构造函数私有化
    private Singleton_hungry(){}
    //定义私有的引用
    private static Singleton_hungry instance = new Singleton_hungry();
    //对外提供获取实例的方法
    public static Singleton_hungry getInstance(){
        return instance;
    }
}
```

2. 懒汉模式：懒汉式是延时加载,他是在需要的时候才创建对象
```java
public class Singleton_lazy {
    //构造函数私有化
    private Singleton_lazy(){}
    private static Singleton_lazy instance;
    //对外提供获取实例的接口
    public static Singleton_lazy getInstance(){
        if (instance == null){
            instance =  new Singleton_lazy();
        }
        return instance;
    }
}

// 懒汉模式存在线程安全问题，用双重校验锁去解决
public class Singleton_lazy2 {
    private Singleton_lazy2(){};
    private static volatile Singleton_lazy2 instance;
    public Singleton_lazy2 getInstance(){
        //第一次校验singleton是否为空（已经创建实例不用竞争锁，提高效率）
        if(instance == null){
            synchronized (Singleton_lazy2.class){
                //第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断doubleLock是null，他就实例化了doubleLock，然后他出了锁，
                //这时候线程B经过等待A释放的锁，B获取锁了，如果没有第二个判断，那么他还是会去new DoubleLock()，再创建一个实例，所以为了防止这种情况，需要第二次判断
                if (instance == null){
                    instance =  new Singleton_lazy2();
                }
            }
        }
        return instance;
    }
}
```

## 13.2、简单工厂模式
简单工厂模式又称为**静态工厂方法**模式，它通过一个工厂类来创建不同类型的对象，客户端只需要知道具体产品的名称即可。
简单工厂模式的优点是简单易用，但是如果需要添加新的产品类型，则需要修改工厂类的代码，违反了开闭原则
```java
public class SimpleFactory {
    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new ConcreteProductA();
        } else if (type.equals("B")) {
            return new ConcreteProductB();
        } else {
            return null;
        }
    }
}
// 使用
Product product = SimpleFactory.createProduct("A");
```
## 13.3、工厂方法模式
工厂方法模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类只负责创建一种产品类型。客户端只需要知道具体工厂类的名称即可。
工厂方法模式的优点是更加灵活，可以更方便地添加新的产品类型，但是需要创建多个工厂类，增加了系统的复杂度。
```java
// 抽象工厂接口
public interface Factory {
    Product createProduct();
}
// 具体工厂类
public class ConcreteFactoryA implements Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

public class ConcreteFactoryB implements Factory {
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
// 使用
Factory factory = new ConcreteFactoryA();
Product product = factory.createProduct();
```
## 13.4、抽象工厂模式
抽象工厂模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类负责创建一组相关的产品类型。客户端需要知道具体的工厂类和产品族的名称。
抽象工厂模式的优点是可以创建一组相关的产品，而且更加灵活，但是需要创建多个工厂类和产品族，增加了系统的复杂度
```java
// 抽象工厂接口
public interface Factory {
    Product createProductA();
    Product createProductB();
}

// 具体工厂类
public class ConcreteFactory1 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA1();
    }

    public Product createProductB() {
        return new ConcreteProductB1();
    }
}

public class ConcreteFactory2 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA2();
    }

    public Product createProductB() {
        return new ConcreteProductB2();
    }
}

// 使用
Factory factory = new ConcreteFactory1();
Product productA = factory.createProductA();
Product productB = factory.createProductB();
```
## 13.5、原型模式
原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而不是通过实例化类来创建。这种模式适用于需要创建多个相似对象的情况，因为它可以减少对象创建的开销和复杂性
原型模式的优点包括：提高了对象创建的效率，减少了重复的代码，简化了对象创建的过程。缺点是如果原型对象的属性较为复杂或包含引用类型的属性，则需要进行深度克隆，否则会影响对象的正确性。
```java
public class Prototype implements Cloneable {
    private String name;
    private List<String> list;

    public Prototype(String name, List<String> list) {
        this.name = name;
        this.list = list;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<String> getList() {
        return list;
    }

    public void setList(List<String> list) {
        this.list = list;
    }

    @Override
    public Prototype clone() throws CloneNotSupportedException {
        Prototype prototype = (Prototype) super.clone();
        // 对包含的引用对象进行深度克隆
        prototype.list = new ArrayList<>(this.list);
        return prototype;
    }
}

```
## 13.6、装饰者模式
装饰者模式是一种结构型设计模式，它允许动态地向一个对象添加新的行为，同时又不影响其原有行为。这种模式的关键在于装饰者类和被装饰者类实现相同的接口，使得装饰者对象可以代替被装饰者对象，从而实现透明性。
在装饰者模式中，有四个角色：

1. 抽象组件（Component）
2. 具体组件（ConcreteComponent）
3. 抽象装饰者（Decorator）：实现抽象组件
4. 具体装饰者（ConcreteDecorator）：继承抽象装饰者

核心思想是：将对象的行为分离出来，使得每个行为都可以被单独地扩展和修改，而不会影响到其他行为。这种分离行为的方式是通过将行为封装到不同的类中，并将这些类组合起来形成一个**对象链**来实现
```java
// 抽象组件
interface Component {
    void operation();
}

// 具体组件
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("具体组件的操作");
    }
}

// 抽象装饰者
class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation();
    }
}

// 具体装饰者A
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者A的操作");
    }
}

// 具体装饰者B
class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者B的操作");
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        ConcreteComponent concreteComponent = new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);
        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);
        concreteDecoratorB.operation();
    }
}

```
## 13.7、代理模式
代理模式是一种结构型设计模式，主要作用是在访问对象时引入一定程度的间接性，以便更好地控制访问和管理对象。
Java中实现代理模式通常有两种方式：静态代理和动态代理
静态代理是指在编译时就已经确定代理类和被代理类的关系，代理类和被代理类都必须实现相同的接口或者继承相同的父类。静态代理的优点是简单易懂，缺点是需要为每一个被代理类写一个代理类，增加了代码量
```java
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// 代理类
class ProxySubject implements Subject {
    private RealSubject realSubject;

    public ProxySubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        System.out.println("ProxySubject.request()");
        realSubject.request();
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxySubject proxySubject = new ProxySubject(realSubject);
        proxySubject.request();
    }
}

```
动态代理是指在运行时动态生成代理类，不需要为每一个被代理类写一个代理类，可以节省代码量。Java中提供了两种动态代理机制：基于接口的动态代理和基于类的动态代理
```java
// 基于接口的动态代理：
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// InvocationHandler实现类
class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("ProxySubject.request()");
        Object result = method.invoke(target, args);
        return result;
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxyHandler proxyHandler = new ProxyHandler(realSubject);
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
                realSubject.getClass().getClassLoader(),
                realSubject.getClass().getInterfaces(),
                proxyHandler);
        proxySubject.request();
    }
}

```
## 13.7、享元模式
享元模式是一种结构型设计模式，它用于减少系统中对象的数量，从而提高系统的性能和效率。在享元模式中，多个对象共享相同的状态和数据，这些状态和数据通常是不可变的，因此可以被多个对象共享使用

1. 抽象享元（Flyweight）：定义享元对象的接口，通常包含一个操作方法。
2. 具体享元（ConcreteFlyweight）：实现抽象享元接口，包含内部状态和外部状态两部分，其中内部状态可以被共享，而外部状态需要在使用时传递给享元对象。
3. 享元工厂（FlyweightFactory）：用于创建和管理享元对象，通常使用工厂模式来实现。

在Java中，可以使用HashMap来存储享元对象，使用享元对象的属性作为HashMap的key，将享元对象作为HashMap的value。这样，当需要创建新的对象时，先在HashMap中查找是否已经存在相同属性的对象，如果存在，则返回已有的对象，否则创建新的对象并将其加入HashMap中
```java
import java.util.HashMap;

public class FlyweightFactory {
    private static final HashMap<String, Flyweight> flyweights = new HashMap<>();

    public static Flyweight getFlyweight(String key) {
        Flyweight flyweight = flyweights.get(key);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}

public interface Flyweight {
    void operation();
}

public class ConcreteFlyweight implements Flyweight {
    private String key;

    public ConcreteFlyweight(String key) {
        this.key = key;
    }

    public void operation() {
        System.out.println("ConcreteFlyweight with key " + key + " is performing operation.");
    }
}

public class Client {
    public static void main(String[] args) {
        Flyweight flyweight1 = FlyweightFactory.getFlyweight("key1");
        Flyweight flyweight2 = FlyweightFactory.getFlyweight("key2");
        Flyweight flyweight3 = FlyweightFactory.getFlyweight("key1");

        flyweight1.operation();
        flyweight2.operation();
        flyweight3.operation();

        System.out.println(flyweight1 == flyweight3); // true
    }
}

```

## 13.8、策略模式
策略模式是一种行为型设计模式，它允许选择算法的不同实现。在策略模式中，算法被封装在单独的类中，并且可以在运行时进行切换，以便在不同的情况下使用不同的算法
在策略模式中，有三个角色：策略接口、具体策略类和上下文类
上下文类包含一个策略接口的引用，并且可以在运行时切换具体策略类的实现
```java
// 策略接口
public interface SortStrategy {
    void sort(int[] data);
}
// 策略实现
public class BubbleSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 冒泡排序算法实现
    }
}

public class QuickSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 快速排序算法实现
    }
}

// 上下文类
public class Sorter {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] data) {
        strategy.sort(data);
    }
}

// 使用
int[] data = {4, 2, 1, 5, 3};
Sorter sorter = new Sorter();
sorter.setStrategy(new BubbleSortStrategy());
sorter.sort(data);

sorter.setStrategy(new QuickSortStrategy());
sorter.sort(data);
```

## 13.9、观察者模式
观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有依赖于它的观察者对象都会得到通知并自动更新
实现观察者模式需要定义两个接口：主题接口和观察者接口。主题接口定义了注册、删除和通知观察者的方法，观察者接口定义了更新自己状态的方法
最典型的应用场景就是消息订阅系统（如微博）
```java
// 被观察者类，即微博用户或话题
class Subject {
    private List<Observer> observers = new ArrayList<>(); // 观察者列表

    public void attach(Observer observer) { // 添加观察者
        observers.add(observer);
    }

    public void detach(Observer observer) { // 移除观察者
        observers.remove(observer);
    }

    public void notifyObservers(String message) { // 通知所有观察者
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 观察者接口，即微博用户
interface Observer {
    void update(String message);
}

// 具体观察者类，即关注了某个微博用户或话题的其他用户
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

// 测试代码
public class Test {
    public static void main(String[] args) {
        Subject subject = new Subject();

        ConcreteObserver user1 = new ConcreteObserver("User1");
        ConcreteObserver user2 = new ConcreteObserver("User2");
        ConcreteObserver topic1 = new ConcreteObserver("Topic1");

        subject.attach(user1);
        subject.attach(user2);
        subject.attach(topic1);

        subject.notifyObservers("Hello world!"); // 发布新消息

        subject.detach(user2); // 取消关注

        subject.notifyObservers("Goodbye!"); // 发布新消息
    }
}

```
# 14、Linux
## 14.1、防火墙常用命令
Firewalld和iptables都是Linux系统中常用的防火墙软件, Firewalld可以在运行时动态添加、删除和修改规则, 使用更加灵活
```shell
# 查看防火墙状态
systemctl status firewalld
# 查看所有开启的端口
firewall-cmd --list-ports
# 放行80端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
# 移除80端口
firewall-cmd --remove-port=80/tcp --permanent
# 重启防火墙
firewall-cmd --reload
```

## 14.2、进程号&端口号查看
```shell
# 查看java项目的进程
jsp
# 根据名称查看进程
ps -ef|grep ims
# 根据端口号查看进程(-alnp:所有连接  -tlnp:tcp连接)
netstat -alnp|grep 8090
# 根据进程号查看项目端口号
netstat -alnp|grep 119343
```
# 15、项目
### 15.1、云+2.0系统


## 3.19、mybatis原理

1. 系统启动的时候，会去创建一个sqlSessionFactory（它是一个单例对象，因为创建开销大），其中它会去加载mybatis全局配置文件和映射文件，封装到Configuration对象中。用来创建sqlSession
> 两个属性分别为：
> DataSource dataSource
> Map<String, MappedStatement> mappedStatements：key为namespace.id， value的MappedStatement对象包括入参，出参，sql语句等信息

2. sqlsession中提供了增删改查等操作的方法，在执行方法时会调用对应Executor执行器执行
3. Executor处理，如果有配置缓存，它会先走二级缓存，再走一级缓存。如果缓存中都没有查到对应的数据，才走底层的JDBC操作，实际就是调用jdbc的statement/ preparedStatement，在调用之前涉及到参数封装，在调用之后处理返回（ResultSet转成ResultType设置的类型）

> 例如：preparedStatement执行前需要把sql中的#{} 替换为 ？
> 这些步骤都是在mapper动态代理类中进行


## 3.20、mybatis插件原理（PageHelper分页原理）
mybatis插件本质就是一个拦截器，就是对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，会执行到代理对象的方法，从而执行自己编写的拦截逻辑。
具体实现：1.创建插件类，实现Interceptor接口。2. 在插件类中重写intercept()方法，实现插件功能。3. 在插件类中重写plugin()方法，返回目标对象的代理对象。4. 在插件类中重写setProperties()方法，读取配置文件中的属性。5. 在MyBatis配置文件中通过标签配置插件。
> PageHelper 的原理是通过拦截 Executor 的 query 方法，从而获取查询 SQL 语句和参数，并根据用户的分页配置信息，自动在查询语句中添加分页的 SQL 语句，最后将修改后的 SQL 语句和参数传递给 Executor 进行查询



# 8、网络
## 8.1、长连接和短连接的区别？
HTTP的长连接和短连接本质上是TCP长连接和短连接
**长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。直到服务器超时自动断开链接，或者客户端主动断开链接
**短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。

> 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。
> Http长连接 和 TCP长连接的区别在于: TCP 的长连接需要自己去维护一套心跳策略。，而Http只需要在请求头加入keep-alive:true即可实现长连接


## 8.2、cookie和session的区别？

1. 存储位置：cookie存储在客户端浏览器中，session存储在服务器端。
2. 安全性：cookie可以被客户端修改和窃取，因此不适合存储敏感信息。而session存储在服务器端，只有服务器可以访问它，因此更加安全。
3. 存储容量：cookie的存储容量有限，通常只能存储少量的数据。而session可以存储大量的数据，因为它存储在服务器端。（具体容量看设置，cookie默认4kb，session几十兆）
4. 过期时间：cookie可以设置过期时间，当过期时，浏览器会自动删除cookie。而session在用户关闭浏览器时会自动过期。

总的来说，cookie适合用于存储少量的非敏感信息，如用户偏好设置、购物车信息等；而session适合用于存储大量的敏感信息，如用户登录状态、权限等