# 1、java基础
## 1.1、面向对象的特征有哪些方面？
**封装**：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了
**继承**：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度
**多态**：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已

## 1.2、访问修饰符 public,private,protected,不写（默认）的区别？
| 修饰符 | 当前类 | 同包 | 子类 | 其它包 |
| --- | --- | --- | --- | --- |
| public | √ | √ | √ | √ |
| protected | √ | √ | √ | × |
| default | √ | √ | × | × |
| private | √ | × | × | × |

## 1.3、floatf=3.4;是否正确？
不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf=(float)3.4;或者写成floatf=3.4F;

## 1.4、JVM、JRE、JDK之间的关系

![JVM JRE JDK关系](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310250949549.png)

JVM：就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。一般与OS操作系统打交道

JRE：java运行环境，包含Java虚拟机、库函数、运行Java应用程序所必须的文件
>javaw(windos java启动器，不显示黑窗口),libraries（外部类库）,rt_jar（核心库）

JDK：java开发工具,包含JRE,以及增加编译器和调试器等用于程序开发的文件
>javac(编译器),debugging（调试器）,tools,javap（反编译工具）

## 1.5、stringBuffer和stringBuilder区别？
stringbuffer线程安全的使用synchronization修饰的方法
stringbuilder线程不安全的，效率更高

## 1.6、重载和重写的区别？
**重载**发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载
**重写**，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变

> 不能根据返回类型来区分重载
> float max(int a, int b);
> int max(int a, int b);
> 上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法


## 1.7、抽象类和接口的区别？
1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制
2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的

## 1.8、= =和equals的区别？

1. equals()没有被重写的情况下等同于 ==

Object的equals()方法源码：
```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```
这用情况= =和equals（）都是引用比较

2. string重写了Object的equals（）方法

这种情况equals（）是值比较

## 1.9、深拷贝和浅拷贝？
**浅拷贝**：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法
**深拷贝**：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容

```java
// 使用对象序列化来实现克隆
public class Room implements Serializable {
    Desk desk;
 
    public Room deepClone() throws Exception{
        //序列化
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
        objectOutputStream.writeObject(this);
        //反序列化
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        Room roomClone = (Room)objectInputStream.readObject();
        return roomClone;
        
    }
}
```

## 1.10、java基本数据类型 - 四类八种

1. 整型：byte 、short 、int 、long
2. 浮点型：float 、 double
3. 布尔型：boolean
4. 字符型：char
| 数据类型名称 | 占用字节 | 封装器类 |
| --- | --- | --- |
| byte（字节型） | 1 | Byte |
| shot（短整型） | 2 | Short |
| int（整形） | 4 | Integer |
| long（长整型） | 8 | Long |
| float（浮点型） | 4 | Float |
| double（双精度浮点型） | 8 | Double |
| boolean（布尔型） | 1 | Boolean |
| char（字符型） | 2 | **Character** |

## 1.11、Object类常用的方法有哪些？

1. hashcode（）：将对象的16进制地址值，经过hash算法换算成整值
2. toString（）：返回该对象的字符串对象
3. equals（）：比较两个对象的地址值是否相同
4. clone（）：实现对象的浅拷贝
5. getclass（）：获取该对象的字节码文件（该对象运行时的类）Class<?>
6. wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法

## 1.12、面向过程和面向对象的理解？
是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么
> 比如：洗衣机洗衣服
**面向过程**：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干
**面向对象**：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干

从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护

## 1.13、ArrayList和LinkedList的区别？

1. 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构
2. 插入/删除效率：Arraylist 在新增/删除元素时，(1)之后的元素都要向后/向前移位(2)扩容 也会影响效率。LinkedList只需要改变前后指针的指向
3. 查询效率：Arraylist 通过元素的序号快速获取元素对象，LinkedList需要遍历去查询

## 1.14、各种容器扩容机制
ArrayList：底层是数组，初始容量为0，当添加第一个元素，扩容为**10** ,当插入数据导致size + 1 > 容器大小时，进行扩容。创建一个新数组，新数组容量为旧数组的**1.5倍** ，并且将旧数组内容通过Array.copyOf全部复制到新数组

HashMap：当HashMap中的元素个数超过数组负载容量时，就会进行数组扩容，负载因子的默认值为0.75。也就是说，默认情况下，数组大小为**16**，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为 2*16=32，**即扩大一倍**，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能

## 1.15、java异常分类
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1673855543907-b4c3abcb-1185-4193-81cf-38ed9ced9e61.png#averageHue=%23fbfafa&clientId=u85999140-f89c-4&from=paste&height=306&id=u60d69b44&originHeight=276&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103901&status=done&style=none&taskId=ubc481606-9b20-48a0-a881-ed3310cbfee&title=&width=771)

## 1.16、如何自定义注解
注解分为两种，元注解和自定义注解
元注解理解为描述注解的注解，有4个：@Target @Retention @Documented @Inherited
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OpLog {
    public OpType opType();
}
```
> @Target: 用来限定某个自定义注解能够被应用在哪些Java元素上面的.TYPE,FIELD,METHOD等
> @Retention：用来修饰自定义注解的生命力。SOURCE源文件，CLASS文件，RUNTIME运行阶段
> @Documented：指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中
> @Inherited：某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解


## 1.17、反射的理解
反射就是在程序运行期间动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。 获取Class对象的三种方式：getClass();
xx.class;
Class.forName("xxx"); 
反射的优缺点： 
优点：运行期间能够动态的获取类，提高代码的灵活性。 
缺点：性能比直接的Java代码要慢很多。 
> 反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化

应用场景：spring的xml配置模式，以及动态代理模式都用到了反射

## 1.18、hashmap原理
hashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对
两个重要的方法put() get()
（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。
（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。

> （需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）
> 如果数组长度不足64，优先会进行扩容


## 1.19、字符串创建的方式
创建字符串由两种方式：
一种是使用字符串直接量，JVM会使用常量池来管理这个字符串，
另一种是使用new关键字，JVM会先使用常量池来管理字符串直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象会被保存在堆内存中。

## 1.20、BIO  NIO  AIO
BIO：同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理，如果连接多了，线程数量不够，就只能等待，即会发生阻塞。 
NIO：同步非阻塞，服务实现模式为一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有IO请求就处理。 
AIO：异步非阻塞，引入了异步通信，采用的是proactor模式，特点是：有效的请求才启动线程，先由操作系统完成再通知服务端。

## 1.21、包装类的自动装箱和自动拆箱
**包装类：**
所有的引用类型的变量都继承于Object类,都可以当做Object类型的变量使用,但基本数据类型却不可以。如果某个方法需要Object类型的参数,但实际传入的值却是数字的话,就需要做特殊的处理了。有了包装类,这种问题就可以得以简化
**自动装箱：**
自动装箱是指把一个基本类型的数据直接赋值给对应的包装类型；
**自动拆箱：**
自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型；
> 通过自动装箱、自动拆箱功能,可以大大简化基本类型变量和包装类对象之间的转换过程

## 1.22、sleep（）和wait（）的区别？

1. 所属的类型不同 - wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 - sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态。
2. 对锁的依赖不同 - wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。 - sleep()不依赖于任何锁,所以在调用后它也不会释放锁。
3. 返回的条件不同 - 调用wait()进入等待状态的线程,需要由notify()/notifyAll()唤醒,从而返回。 - 调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。

## 1.23、泛型和泛型擦除
（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。 
（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。

## 1.24、foreach遍历过程可以删除元素吗？
使用foreach遍历时删除（list.remove）会抛异常（ConcurrentModificationException  ）
foreach循环在实际执行时，其实使用的是Iterator，调用next()方法获取下一个元素时，核心逻辑就是比较modCount（修改次数）和expectedModCount这2个变量的值是否相等（一个是list的，一个是迭代器的），如果不相等则抛出异常，调用list的remove方法时，会吧modCount自增，但expectedModCount不变。所以下一次比较时会抛异常。调用迭代器iterator的remove方法时，会同时改变两个变量的值，所以不会抛出异常
> 所以一般list删除使用迭代器或者遍历通过下标删除
> 注意，下标删除后后面的元素会前移，所以删除后要倒退一位
> for (int i = 0; i < lists.size(); i++) {
>             String ele =  lists.get(i);
>             if ("a".equals(ele)){
>                 lists.remove(ele);
>                 i--;// 删除后倒退一位
>             }
>         }
> 或者倒叙删除
> for (int i = lists.size()-1; i >= 0; i--) {// 倒叙删除
>             String ele =  lists.get(i);
>             if ("a".equals(ele)){
>                 lists.remove(ele);
>             }
>         }


## 1.25、java日志框架
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676796097509-b3e0aaed-03dc-45e2-b482-9ea87b30e559.png#averageHue=%23bac9da&clientId=uacd32e8a-22d1-4&from=paste&height=848&id=ua2513e35&originHeight=848&originWidth=1749&originalType=binary&ratio=1&rotation=0&showTitle=false&size=500284&status=done&style=none&taskId=u8e6d30ed-3d11-4c8a-85bb-b5de07c0e0b&title=&width=1749)
日志门面作用：面向接口开发，不再依赖具体的实现类，减少代码的耦合

## 1.26、hashcode允许key和value为null吗？
```java
static final int hash(Object key) {
        int h;
        //当key等于null的时候，不走hashCode()方法
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；
hashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；
因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个

## 1.27、异步多路复用

## 1.28、String为什么不可变？为什么这样设计？
什么是不可变: 对象属性的值是不可变的。
private final char value[]

1. final表示该变量引用地址是不可变的
2. private 表示私有变量，外部不能访问，并且string类并未对外提供该value数组的修改方法。

为什么这样设计？

1. 字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变
2. hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致

## 1.29、TreeMap原理
treeMap基于红黑树（Red-Black tree）实现，该映射根据其键的自然顺序进行排序，或者根据映射时提供的comparator进行排序，取决于他的构造方法。TreeMap的基本操作containsKey,get,put和remove的时间复杂度是log(n)
> 以put为例： 按排序二叉树的方式插入节点，插入key比遍历节点的key小就往左边，大就往右，相等就替换。在插入结束后会对整个红黑树进行调整，已使它达到基本平衡，保证操作效率


## 1.30、TreeSet原理
TreeSet的底层是TreeMap，添加的数据存入了map的key的位置，而value则固定是PRESENT。TreeSet中的元素是有序且不重复的，因为TreeMap中的key是有序且不重复的
> privatestaticfinal Object PRESENT = new Object();

## 1.31、自然排序和定制排序

1. 自然排序：实现Comparable接口，实现compareTo方法
> 典型实现：String，Integer，Date等

2. 定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序
```java
Collections.sort(arrayList, new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(o2);
        }
});
```

## 1.32、try-catch-finally哪个可以省略？
catch 和 finally 语句块可以省略其中一个，否则会编译错误
```java
        int i = 8;
		try {
			i += 2;
		} finally {
			i = 11;
		}


 		try {
			int i = 10;
			i += 2;
			System.out.println(i);
		} catch (Exception e) {
			e.printStackTrace();
		}
```
# 2、jvm
## 2.1、jvm内存模型

1. **程序计数器（线程私有）**

当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
> 特点：
（1）.为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是线程私有的内存区域
（2）.如果线程执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个Native方法，计数器的值为空
（3）.Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域


2. **虚拟机栈（线程私有）**

每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同
> 局部变量表：存放方法参数和方法内部定义的局部变量
操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区
动态链接：将这些符号引用转换为调用方法的直接引用


3. **本地方法栈（线程私有）**

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而本地方法栈为虚拟机使用到的Native方法服务（一个Native Method就是一个java调用非java代码的接口）

4. **堆（线程共享）**

Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）
> 从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区

（1）新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2
> 通过参数 –XX:NewRatio 来指定

（2）Eden : from : to = 8 : 1 : 1
> 以通过参数 –XX:SurvivorRatio 来设定

（3）最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一

5. **方法区（线程共享）**

方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、常量以及编译器编译后的代码等。（GC分代收集扩展至方法区，可以不必为方法区编写专门的内存管理，但带来的后果是容易碰到内存溢出的问题。元空间占用本地内存，也就是说，只要不碰触到系统内存上限，方法区会有足够的内存空间）
> jdk1.7前：采用永久代
jdk1.7：字符串常量池被移到堆内存
jdk8：废除了永久代。类的元信息会被放入本地内存（元空间）。将类的静态变量和字符串常量池放入到java堆


## 2.2、类加载器类型？
类加载器：通过类的全限定名获取类的二进制字节流（通俗来说就是把class文件装进虚拟机）

1. 启动类加载器

使用c++实现，加载jre和jre/lib目录下的核心库

2. 扩展类加载器

java编写，父加载器为启动类加载器，从jre/lib/ext下加载类库

3. 应用类加载器

负责加载用户类路径（classpath）上的指定类库

## 2.3、类加载过程
类加载机制：虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制

1. **加载阶段**

（1）通过一个类的全限定名来获取定义此类的二进制字节流
（2）在内存中生成一个代表这个类的java.lang.Class对象

2. **连接阶段**

（1）验证： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
（2）准备：为类的静态变量分配内存，并将其赋默认值
（3）解析：将常量池中的符号引用替换为直接引用（内存地址）的过程
> 符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。

> 直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针

3. **初始化阶段**

为类的静态变量赋初值
>  赋初值两种方式：

> （1）定义静态变量时指定初始值。如 private static String x="123";

> （2）在静态代码块里为静态变量赋值。如 static{ x="123"; } 

>  注意：只有对类的主动使用才会导致类的初始化。


初始化顺序：
（1）静态初始化 ：父类静态成员和static块-子类静态成员和static块
（2）父类初始化：父类普通成员和非static块-父类构造函数
（3）子类初始化：子类普通成员和非static块-子类构造函数

## 2.4、什么是双亲委派机制？有什么好处？

1. 概念：

当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类

2. 好处：

（1）避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍
（2）保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1673918700761-d2993629-8eda-41a1-976e-6da8c9092609.png#averageHue=%23f9f9f9&clientId=u85999140-f89c-4&from=paste&height=566&id=u9a933591&originHeight=566&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47695&status=done&style=none&taskId=ueca8d068-73cc-4518-90a0-aff355e9ead&title=&width=833)

## 2.5、如何判断一个对象是否可以被回收？

1. **引用计数法**

概念：每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收
缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）

2. **可达性分析法**

概念：设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收
> 补充：循环依赖

```java

public class MyObject {
    public Object ref = null;
    public static void main(String[] args) {
        MyObject myObject1 = new MyObject();
        MyObject myObject2 = new MyObject();
        myObject1.ref = myObject2;
        myObject2.ref = myObject1;
        myObject1 = null;
        myObject2 = null;
    }
}
```

> 从上面的代码可以轻易地发现myObject1与myObject2互为引用，我们知道如果采用引用计数法，myObject1和myObject2将不能被回收，因为他们的引用计数无法为零

> 当代码执行完line7时，两个对象的引用计数均为2。此时将myObject1和myObject2分别置为null，以前一个对象为例，它的引用计数将减1。若要满足垃圾回收的条件，需要清除myObject2中的ref这个引用，而要清除掉这个引用的前提条件是myObject2引用的对象被回收，可是该对象的引用计数也为1，因为myObject1.ref指向了它。以此类推，也就进入一种死循环的状态


## 2.6、根对象
**根对象**：GC Root Object可以从Java堆的外部访问，也就是不受GC的自动回收管制。可以理解为有免死金牌的Java对象

1. 虚拟机栈中引用的对象
2. 本地方法栈中引用的对象
3. 方法区类静态属性引用的对象
4. 方法区常量引用的对象

## 2.7、垃圾收集器
**新生代垃圾收集器**

1. Serial（串行）收集器

Serial收集器在JDK1.3.1之前是虚拟机新生代收集的唯一选择。它是一种单线程收集器
> 优点：简单高效，拥有很高的单线程收集效率
> 缺点：收集过程需要暂停所有线程
> 算法：复制算法应用

2. ParNew 收集器

可以把这个收集器理解为Serial收集器的多线程版本
> 优点：在多CPU时，比Serial效率高。
> 缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。
> 算法：复制算法

3. Parallel Scavenge 收集器

并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量
> 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)
比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量=(120-1)/120=99.167%。
若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务


**老年代垃圾收集器**

1. serial old

Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用"**标记-整理算法**"，运行过程和Serial收集器一样

2. Parallel old

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和"**标记-整理算法**"进行垃圾回收，吞吐量优先。

3. cms

老年代收集器，采用标记-清除算法。追求最短回收停顿时间

   1. 初始标记：标记GC Roots直接关联的对象，速度快
   2. 并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作
   3. 重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记
   4. 并发清除：清除标记的对象
> （1）对CPU资源非常敏感，CPU少于4个时，CMS对用户程序的影响可能变得很大（2）采用标记清除算法会产生内存碎片

![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658305602785-8661cce7-3b84-4837-992a-f8957b2bb262.png?x-oss-process=image%2Fresize%2Cw_526%2Climit_0#averageHue=%23e9ebe4&from=url&height=209&id=Z3Ldh&originHeight=182&originWidth=526&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=604)

**整堆收集器**

1. G1

G1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏

   1. 初始标记：标记GC Roots直接关联的对象
   2. 并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作
   3. 重新标记：修正并发标记期间用户进程继续运行而产生变化的标记
   4. 筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划

![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658306681886-fc61615b-bdef-4aa3-8e20-ac665bb7efe2.png?x-oss-process=image%2Fresize%2Cw_513%2Climit_0#averageHue=%23ebede6&from=url&id=K3S3V&originHeight=182&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

jdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.9 默认垃圾收集器G1

## 2.8、垃圾回收算法
**标记清除算法**

1. 概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象
2. 优点：算法简单
3. 缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间

**标记整理算法（老年代默认）**

1. 概念：将标记的对象移动到内存的一端，清除边界外的所有空间
2. 优点：解决了标记清除算法的碎片问题
3. 缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）

**复制算法（新生代默认）**

1. 概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推
2. 优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代
3. 缺点：浪费内存空间，始终要有一个空闲的survivor

## 2.9、内存溢出和内存泄漏
内存溢出：是程序在申请内存时，没有足够的内存空间供其使用
内存泄漏：内存空间使用完毕之后未回收

**内存泄漏的原因？**
（1）static字段引起的内存泄露
大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。
> 解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式

（2）未关闭的资源导致内存泄露
每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。
> 解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块


## 2.10、强引用 软引用 弱引用 虚引用

1. 强引用，以new关键字创建的引用都是强引用，被强引用引用的对象永远都不会被回收。
2. 软引用：以SoftRererenc引用对象，被软引用引用的对象只有在内存空间不足时会被垃圾回收。
> 软引用主要用于实现缓存，当内存不足时，可以回收不常用的对象

3. 弱引用，以WeakReference引用对象，被弱引用引用的对象一定会被回收，它只能存活到下一次垃圾回收。（弱引用不会增加引用数量）
> WeakReference<Obejct> wf = new WeakReference<Obejct>(new Object);

4. 虚引用：以PhantomReference引用对象，一个对象被引用引用后不会有任何影响，也无法通过该引用来获取该对象，只是其在被垃圾回收时会收到一个系统通知（作用是用来跟踪它所引用的对象被垃圾收集器回收的活动）
> Java4种引用的级别由高到低依次为：
> **强引用  >  软引用  >  弱引用  >  虚引用**



## 2.11、内存溢出和内存泄漏
内存溢出：程序在申请内存时，没有足够的内存空间供其使用，抛出OutOfMemory异常
内存泄漏：内存空间使用完毕后未回收（程序中有引用没有释放，不能被GC回收），一次内存泄漏可能不会有很大的影响，但长时间的内存泄漏，堆积到一定程度就会产生内存溢出
> 使用完资源后及时关闭


## 2.12、对象一定在堆内存分配吗？
经过逃逸分析，对于一些不逃逸的小对象，可以将其分配在栈内存中，而不是堆内存中
> 逃逸情况：
> （1）方法逃逸：对象直接作为返回值。可以理解为跳出方法的作用范围
> （2）线程逃逸：对象被多个线程访问，比如被赋值给实例变量。可以理解为跳出了当前线程


## 2.13、class常量池，运行时常量池，字符串常量池

1. class常量池：每个class文件都包含有一个class常量池，包含符号引用和字面量。符号引用就是类的全限定名和字段名称，描述符。字面量就是具体的值，包含数字型和字符型
2. 运行时常量池：运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，**并且把里面的符号地址变为真实地址，数值型字面量存放在运行时常量池，字符型字面量存放到字符串常量池**
3. JVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1677312989942-7bd923d5-acb4-43c5-a3f5-6087073ec2ea.png#averageHue=%23e0e3e0&clientId=u3006635b-f833-4&from=paste&height=735&id=u142aca98&originHeight=735&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=593063&status=done&style=none&taskId=u04f9859f-a048-4f7c-b348-43fcb14fd56&title=&width=960)

## 2.14、string  s= "abc"创建了几个对象？
0个或1个

1. 首先会去字符串常量池查找是否有该string对象
2. 没有，创建一个string对象，并在字符串常量池中创建一个entry对象指向该string对象，s同时也指向该string对象
3. 有，不会创建对象，s直接指向该对象

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1677461473395-f80513be-4cef-4ad2-9da5-8849a2c3f8df.png#averageHue=%23d8e1d4&clientId=u3588c3ec-f797-4&from=paste&height=437&id=uc8b1349b&originHeight=801&originWidth=987&originalType=binary&ratio=1&rotation=0&showTitle=false&size=740703&status=done&style=none&taskId=u3a3e0338-f908-40fb-a73b-d63c7101f61&title=&width=539)
> 字符串常量池c++实现，本质就是一个hashtable，在常量池中找"abc"的过程和hashmap类似（计算"abc"的hash值再与数组长度做做取模运算，得到桶的位置，然后equals在链表中查找）
> java的hashmap是hash&(数组长度-1)，原因是与运算快


## 2.15、String s = new String("abc")创建几个对象？
1个或2个
如果常量池已经存在abc对象，只创建1个String对象。并不存在就创建2个String对象
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1677463295209-0aad045c-26af-41ea-9703-c8eb2906a69c.png#averageHue=%23e7ece4&clientId=u3588c3ec-f797-4&from=paste&height=408&id=u1a667fcf&originHeight=408&originWidth=493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=240963&status=done&style=none&taskId=ub1a20bf8-e542-4608-b49b-4a4da7e989d&title=&width=493)

## 2.16、jvm对象何时会进入老年代

1. 达到晋升年龄：新生代对象在经历每次GC的时候，如果没有被回收，则对象的年龄+1。当年龄超过阈值的时候，便会进入老年代。默认情况下，阈值为15（为什么15？对象头年龄为4bit）
2. 大对象直接进入老年代。比如 -XX:PretenureSizeThreshold =1024，那么就表示超过1kb大小的对象在垃圾回收时直接进入到老年代（大对象：很长的字符串或数组）
3. 动态年龄判断：动态年龄判断。如果年龄1+年龄2+ ··· +年龄n的对象的大小超过了当前Survivor区的内存的一半，则年龄超过n的对象进入老年代
# 3、ssm
## 3.1、spring依赖注入方式

1. 属性注入

这里是使用 @Autowired 注解注入。另外也有 @Resource 以及 @Inject 等注解，都可以实现注入
![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1674952676483-cc8d8c37-0eca-457a-8459-0bdbd5fe2a39.webp#averageHue=%23282c35&clientId=ud4b36693-cbbf-4&from=paste&height=211&id=u8e5f6807&originHeight=232&originWidth=771&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u867318be-2d25-4ec0-8dc4-37fb4510e25&title=&width=700)

2. 构造方法注入

如果类只有一个构造方法，那么 @Autowired 注解可以省略；如果类中有多个构造方法，那么需要添加上 @Autowired 来明确指定到底使用哪个构造方法
![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1674952714725-48d6f682-03ac-4a07-913c-4e9cfc5abcaf.webp#averageHue=%23292d36&clientId=ud4b36693-cbbf-4&from=paste&id=u28c488c2&originHeight=303&originWidth=696&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5ea652b-f051-4132-b1d8-aa419b45726&title=)

3. set方法注入

set 方法注入太过于臃肿，实际上很少使用
![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1674952878239-42017dc4-dc63-4aa7-a94f-320cb420d6f1.webp#averageHue=%23292d35&clientId=ud4b36693-cbbf-4&from=paste&height=310&id=u2b6bf561&originHeight=317&originWidth=709&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u056464db-8a1b-43d0-b763-fe643205de7&title=&width=694)

## 3.2、ioc是什么
ioc控制反转，就是反转创建对象的方式，由我们自己创建改为IOC容器帮我们创建。ioc容器实际上就是一个map，里面存的是各种对象，在项目启动的时候。读取配置文件中的bean节点，还有打上@component等注解的类，通过反射创建对象放到这个map里。这时我们既可以通过依赖注入（DI），从容器中直接获取对象。
> IOC解决耦合问题的一种涉及思想，DI是实现IOC的一种方式，或者说是实现IOC重要的一环

## 3.3、aop是什么
AOP是面向切面编程，它是一种编程思想，它是一种通过**预编译方式**和**运行期间动态代理**的方式实现不修改源代码的情况下给程序动态添加功能的一种技术，可以降低代码的耦合度，便于管理，提高代码的可重用性。
 AOP的实现方式有两种： 
**JDK动态代理**，可以在运行时创建接口的代理实例。** **
**CGLIB动态代理**：可以在运行期间创建子类的动态实例（当目标对象不存在接口时,Spring AOP就会采用这种方式,在子类实例中织入代码）
## 3.4、spring aop实现日志

1. 方式1：使用execution表达式定义切点
2. 方式2：使用annotation定义切点
```java
@Aspect
@Component
@Slf4j
public class SysLogAspect {

    /**
     * Controller层切点,SysLog是自定义的注解
	 * @Pointcut("@annotation(cn.zld.springbootwebsockettest.annotation.LogMethod)")
     */
    @Pointcut("@annotation(com.xxx.xxx.SysLog)")
    public void SysLogPointAspect() {
    }


    /**
     * @Description 环绕通知  用于拦截Controller层记录用户的操作
     */
    @Around("SysLogPointAspect()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        //*========控制台输出=========*//
        log.info("==============访问请求==============\n");
      
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
       
        String requireType = request.getMethod();
        String requireUrl = request.getRequestURI();

        // 获取注解信息
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        SysLog syslog = method.getAnnotation(SysLog.class);

        //*========数据库日志=========*//
        // 保存日志到数据库.....
      
      	// 方法执行开始
        long beginTime = System.currentTimeMillis();

        //执行方法
        Object result = joinPoint.proceed();

        //执行时长(毫秒)
        long execTime = System.currentTimeMillis() - beginTime;
        return result;
    }
}

```

## 3.5、spring 事务实现

1. 编程式事务：利用TransactionTemplate模板通过编程的方式实现事务管理,而无需关注资源获取、复用、释放、事务同步及异常处理等操作
2. 声明式事务 ：使用@Transactional注在类或者方法上。 使用**isolation**属性声明事务的隔离级别,使用**propagation**属性声明事务的传播机制

## 3.6、spring事务传播机制
事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行
（eg：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的）

（1）**propagation_required**:当前方法必须运行在事务中，如果当前事务存在，方法将会在该事务中运行，否则会启动一个新的事务
（2）**propagation_requires_new**:表示当前方法必须运行在自己的事务，一个新的事务将会启动，当前事务存在，将会被挂起
（3）**propagation_mandatory**:当前方法必须运行在事务中。如果没有一个活动的事务，则抛出异常
（4）**propagation_supports**:如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行
（5）**propagation_not_supported**：总是非事务地执行，并挂起任何存在的事务
（6）**propagation_never**：总是非事务地执行，如果存在一个活动事务，则抛出异常
（7）**propagation_nested**： 如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务,就开启一个新事务
（注意区分propagation_required：嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚）

## 3.7、springBoot的理解
Spring Boot本身不提供Spring的核心功能,而是作为Spring的脚手架框架,它帮你完成了一些Spring Bean配置，达到快速构建项目的目的
Spring Boot优点,：

- 可以快速构建项目 
- 可以对主流开发框架的无配置集成 
- 项目可独立运行,无需外部依赖Servlet容器 
- 提供运行时的应用监控 （springboot Admin）
- 可以极大地提高开发、部署效率 

## 3.8、springBoot自动配置原理
> 自动配置：它是指基于你引入的依赖Jar 包，对 SpringBoot 应用进行自动配置。它为SpringBoot框架的“开箱即用”提供了基础支撑

1.启动类@SpringBootApplication是一个复合注解，包含了@EnableAutoConfiguration
2.通过@EnableAutoConfiguration包含了@Import({AutoConfigurationImportSelector.class})，它会将AutoConfigurationImportSelector这个类导入到spring容器中
3.AutoConfigurationImportSelector  中的 selectImports方法会读取所有jar包下META-INF/spring.factories，然后筛选出以enableAutoConfiguration.class为key的配置类全限定名，通过string数组返回（这里类似于java的spi机制），注入Spring容器,就可以完成依赖框架的自动配置

## 3.9、springBoot启动流程

1. 加载Spring Boot的配置文件

Spring Boot的配置文件可以是application.properties或application.yml，Spring Boot会在启动时自动加载这些配置文件，读取其中的配置信息。

2. 创建Spring应用上下文

Spring Boot会根据配置文件中的信息创建Spring应用上下文，Spring应用上下文是整个Spring应用的核心对象，它负责管理Spring应用中的各种Bean。

3. 扫描并加载Bean

Spring Boot会根据配置文件中的信息扫描并加载Bean，这些Bean可以是@Service、@Repository、@Controller、@Component、@Configuration等注解标注的类。

4. 自动配置

Spring Boot会根据配置文件中的信息自动配置各种功能，例如自动配置数据库连接池、Web服务器、缓存等。

5. 启动应用

最后，Spring Boot会启动应用，开启Web服务器，等待HTTP请求的到来。

## 3.10、springmvc执行流程

1. 客户端发送请求到DispatcherServlet。
2. DispatcherServlet根据请求的URL找到对应的HandlerMapping。
3. HandlerMapping返回对应的HandlerExecutionChain，其中包含处理请求的Controller以及拦截器。
4. DispatcherServlet根据返回的HandlerExecutionChain取出对应的Controller，并调用其处理方法。
5. Controller处理请求，并返回一个ModelAndView对象。
6. DispatcherServlet根据返回的ModelAndView对象，调用对应的ViewResolver进行视图解析。
7. ViewResolver返回对应的View对象。DispatcherServlet将Model传递给View，View对Model进行渲染。
8. DispatcherServlet将渲染后的视图返回给客户端

 

## 3.11、bean的生命周期
总体来说分为实例化、属性赋值、初始化、销毁这几个步骤：具体如下

1. 解析xml配置或者注解的类，得到BeanDefinition，通过BeanDefinition反射创建Bean对象。
2. 对Bean对象进行属性填充
3. 回调实现Aware接口的方法，比如BeanNameAware
> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。
	但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。
	也就是说spring aware 的这些接口的存在，让我们可以获取、修改beanName（getBeanName）、事件发布（applicationContext.publishEvent）等

4. 调用BeanPostProcessor的前置处理器，调用init初始化方法，调用BeanPostProcessor的后置处理器
5. 将创建的Bean对象放入一个Map，业务中使用Bean对象。
6. Spring容器关闭时调用DisposableBean的destory方法。

> （初始化和销毁是用户能自定义扩展的两个阶段）


## 3.12、BeanFactory和ApplicationContext的区别？

1. 这两个接口都可以表示Spring容器，BeanFactory是Spring里面最底层的接口，可以称之为“低级容器”；ApplicationContext可以称之为“高级容器”，它是BeanFactory的子接口，同时继承了多个接口，功能更为丰富，比如继承了MessageSource支持国际化，（ResourceLoader）统一的资源文件访问方式等。
2. BeanFactory采用延迟加载的方式注入Bean,只有在使用到这个对象的时候才会去加载实例化；ApplicationContext是在容器启动时，一次性创建了所有的Bean。
> （1）beanFactory使用时才去加载，不能及时发现配置错误。ApplicationContext在启动的时候就会发现错误
> （2）因为是启动加载，当bean较多时，applicationContext启动慢，占用内存空间大


## 3.13、java SPI的理解
SPI: service provider interface，它是一种基于接口的动态扩展机制，相当于java里提供了一套标准接口，然后第三方去实现这个接口来完成功能的扩展。比如java sdk中提供了sql.Driver的标准接口，不同的数据库厂商（mysql，oracle等）实现这个接口，然后在项目中引入对应的依赖，通过serviceLoader在运行时发现并加载实现类
java SPI基本条件：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676791123931-b0627430-eb0a-4426-bbef-7f6008d3f6c9.png#averageHue=%23fefffd&clientId=uacd32e8a-22d1-4&from=paste&height=257&id=u69f3d0d4&originHeight=257&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60156&status=done&style=none&taskId=u92847bd8-a690-439c-90dc-8e25139d367&title=&width=602)

## 3.14、springboot起步依赖
在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。我们的工程继承starter-parent后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题

## 3.15、springboot内置tomcat

1. 引入spring-boot-starter-web同时会默认引入spring-boot-starter-tomcat，即Tomcat启动的相关环境
2. 依赖于SpringBoot的自动配置。项目启动的过程中，扫描classpath下的META-INF/spring.factories，实例化工厂对象TomcatServletWebServerFactory，在调用run()方法的时候完成Tomcat对象的创建，环境设置和启动，从而实现Tomcat容器的自动化处理

## 3.16、springboot优点

1. 起步依赖，简化依赖管理
2. 自动配置，遵循约定大于配置，简化配置（内置tomcat就是依赖于自动配置）
3. Spring Boot Actuator ，提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理Spring Boot 应用

## 3.17、@Import注解的使用
用于向ioc容器中注入bean对象

1. 参数value接收一个Class数组，将你传入的类以全类名作为id加入IOC容器中
2. ImportSelector强调的是复用性，使用它需要创建一个类实现ImportSelector接口，实现方法的返回值是字符串数组，也就是需要注入容器中的组件的全类名
3. 创建一个ImportBeanDefinitionRegistrar的实现类，实现registerBeanDefinitions方法，对组件进行注入

## 3.18、Spring解决循环依赖问题
| **缓存** | **说明** |
| --- | --- |
| singletonObjects | 第一级缓存，存放可用的成品Bean。 |
| earlySingletonObjects | 第二级缓存，存放半成品的Bean，半成品的Bean是已创建对象，但是未注入属性和初始化。用以解决循环依赖。 |
| singletonFactories | 第三级缓存，存的是Bean工厂对象，用来生成半成品的Bean并放入到二级缓存中。用以解决循环依赖。 |

1. A 调用doCreateBean()创建Bean对象：由于还未创建，从第1级缓存singletonObjects查不到，此时只是一个半成品（提前暴露的对象），放入第3级缓存singletonFactories。
2. A在属性填充时发现自己需要B对象，但是在三级缓存中均未发现B，于是创建B的半成品，放入第3级缓存singletonFactories。
3. B在属性填充时发现自己需要A对象，从第1级缓存singletonObjects和第2级缓存earlySingletonObjects中未发现A，但是在第3级缓存singletonFactories中发现A，将A放入第2级缓存earlySingletonObjects，同时从第3级缓存singletonFactories删除。
4. 将A注入到对象B中。
5. B完成属性填充，执行初始化方法，将自己放入第1级缓存singletonObjects中（此时B是一个完整的对象），同时从第3级缓存singletonFactories和第2级缓存earlySingletonObjects中删除。
6. A得到“对象B的完整实例”，将B注入到A中。
7. A完成属性填充，执行初始化方法，并放入到第1级缓存singletonObjects中。

## 3.19、mybatis原理

1. 系统启动的时候，会去创建一个sqlSessionFactory（它是一个单例对象，因为创建开销大），其中它会去加载mybatis全局配置文件和映射文件，封装到Configuration对象中。用来创建sqlSession
> 两个属性分别为：
> DataSource dataSource
> Map<String, MappedStatement> mappedStatements：key为namespace.id， value的MappedStatement对象包括入参，出参，sql语句等信息

2. sqlsession中提供了增删改查等操作的方法，在执行方法时会调用对应Executor执行器执行
3. Executor处理，如果有配置缓存，它会先走二级缓存，再走一级缓存。如果缓存中都没有查到对应的数据，才走底层的JDBC操作，实际就是调用jdbc的statement/ preparedStatement，在调用之前涉及到参数封装，在调用之后处理返回（ResultSet转成ResultType设置的类型）
> 例如：preparedStatement执行前需要把sql中的#{} 替换为 ？
> 这些步骤都是在mapper动态代理类中进行


## 3.20、mybatis插件原理（PageHelper分页原理）
mybatis插件本质就是一个拦截器，就是对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，会执行到代理对象的方法，从而执行自己编写的拦截逻辑。
具体实现：1.创建插件类，实现Interceptor接口。2. 在插件类中重写intercept()方法，实现插件功能。3. 在插件类中重写plugin()方法，返回目标对象的代理对象。4. 在插件类中重写setProperties()方法，读取配置文件中的属性。5. 在MyBatis配置文件中通过<plugin>标签配置插件。
> PageHelper 的原理是通过拦截 Executor 的 query 方法，从而获取查询 SQL 语句和参数，并根据用户的分页配置信息，自动在查询语句中添加分页的 SQL 语句，最后将修改后的 SQL 语句和参数传递给 Executor 进行查询



# 4、数据库
## 4.1、事务的特性
如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败

| **事务特性** | **含义** |
| --- | --- |
|  原子性（Atomicity） | 一个事务内的所有操作要么都执行，要么都执行失败 |
|  一致性（Consistency） | 事务执行前与执行后，数据库中数据应该保持相同的状态。如：转账前总金额与转账后总金额相同。 |
|  隔离性（Isolation） | 指的是一个事务在最终提交前，对其它事务是不可见的 |
|  持久性（Durability） |  如果事务执行成功，对数据库的操作是持久的。 |

## 4.2、并发访问下事务产生的问题
当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：

1. 脏读： 一个事务（用户）读取到了另一个事务没有提交的数据
2. 不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。
3. 幻读：在一次事务中，多次读取到的条数不一致

## 4.3、事务的隔离级别
为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别

| **级别** | **名字** | **隔离级别** | **脏读** | **不可重复读** | **幻读** | **数据库默认隔离级别** | 解释 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 读未提交 | read uncommitted | 是 | 是 | 是 |  | 事务A可以读取到事务B未提交的数据 |
| 2 | 读已提交 | read committed | 否 | 是 | 是 | Oracle和SQL Server | 事务A只能读取其它事务已提交的数据（避免了脏读） |
| 3 | 可重复读 | repeatable read | 否 | 否 | 是 | MySQL | 保证在同一个事务中多次读取同样数据的结果是一样的 |
| 4 | 串行化 | serializable | 否 | 否 | 否 |  | 事务串行化顺序执行 |

> 隔离级别越高，安全性就越高，性能越低


## 4.4、mysql索引分类

1. 按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 
2. 按物理存储分类可分为：聚簇索引（innodb）、非聚簇索引（myisam）。 
> 聚簇索引：顾名思义，索引和数据是放在一块的。其叶子节点中存放的就是整张表的行记录数据。我们称之为聚集索引（如果创建了主键，这个主键索引就是聚簇索引，如果没有，innodb建立一个隐藏的row-id作为聚集索引）
> 非聚集索引：一般也称为二级索引或者辅助索，非聚集索引的叶子节点不存储表中的数据，而是存储索引值和数据对应主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表

3. 按字段特性分类可分为：主键索引、唯一索引、普通索引、前缀索引。
> **主键索引**：建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值
> **唯一索引**：建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空
> **普通索引**：建立在普通字段上的索引被称为普通索引
> **前缀索引**：文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快
> CREATEINDEX index_name ONtable_name (column_name(length));

4.  按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。
> 单列索引：建立在单个列上的索引被称为单列索引
> 联合索引：建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引
> （复合索引遵守“最左前缀”原则，即在查询条件中从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分）


## 4.5、索引设计原则
**适合建索引的场景**
1. 频繁作为where条件语句查询的字段
2. 关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等
3. 分组排序字段可以建立索引
4. 统计字段可以建立索引（如.count(),max()）

**不适合建索引的场景**
1. 频繁更新的字段不适合建立索引（需要重建索引）
2. where条件中用不到的字段不适合建立索引
3. 表数据可以确定比较少的不需要建索引
4. 数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值

## 4.6、索引失效的情况

1.  or连接的条件不是每一个列都有索引，这时有索引的列也会失效 
2.  复合索引遵守“最左前缀”原则，在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，如果遇到范围查询(>、<、between、like等)，就停止后边的匹配
```
eg：建立复合索引index:(a,b,c) --- 实际上已经建立了三个联合索引(a)、(a,b)、(a,b,c)
select * from table where a = '1'  //走索引
select * from table where c = '1'  //不走索引
where a like 'xxx%' and b=yyy and c=zzz 
```

3. like查询是以%开头（以%结尾，索引可以使用）
> B+树，索引是有序排列的。索引的排列顺序是根据比较字符串的首字母排序的，如果首字母相同，就根据比较第二个字母进行排序，以此类推。以%开头，首字母不确定

4. 存在索引列的数据类型隐形转换，则用不上索引（比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引）
5. where 子句里对索引列上有数学运算，用不上索引
6. where 子句里对有索引列使用函数，用不上索引
7. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引（比如数据量极少的表）

## 4.7、InnoDB和MyISAM
innoDB：innodb是mysql默认存储引擎，支持事务，行锁和外键等
MyISAM：myisam是mysql5.1版本前默认存储引擎，不支持事务，外键。默认锁的粒度为表锁

|  | InnoDB | MyISAM |
| --- | --- | --- |
| 外键 | 支持 | 不支持 |
| 事务 | 支持 | 不支持 |
| 锁 | 支持表锁和行锁 | 支持表锁 |
| 表结构 | 数据和索引集中存储 | 数据和索引分开存储 |
| 索引 | 聚簇索引 | 非聚簇索引 |

## 4.8、数据库三大范式

1. **第一范式（1NF）**：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式
> 比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定

2.  **第二范式（2NF）**：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 
3.  **第三范式（3NF）**：消除传递依赖，每列都直接依赖于主键
> 假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式


> 所谓反范式化，是一种对范式化设计的数据库的**性能优化策略**，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率


## 4.9、说说缓存穿透、击穿、雪崩的区别

## 4.10、 数据库为什么用B+树索引（平衡 b b+区别）
**二叉查找树：**二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点
**平衡二叉树：**平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1
> 平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快

**B树：**从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据。平衡二叉树可是每个节点只存储一个键值和数据的，如果我们要存储海量的数据，二叉树的节点将会非常多，高度也会极其高。
图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675519747490-4a412d08-3eac-45f1-8dea-166db4fbaaf7.png#averageHue=%23ebecc3&clientId=u298f05d4-9254-4&from=paste&id=Kvmj1&originHeight=458&originWidth=1060&originalType=url&ratio=1&rotation=0&showTitle=false&size=258461&status=done&style=none&taskId=uaebd7b1c-90ba-44bb-9e3c-47d89b2c786&title=)
B+树：B+ 树是对 B 树的进一步优化.
①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。
②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，通过双向链表关联。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675521068729-d7f24861-ca9e-40b7-ae7a-d8a8d4387ed1.png#averageHue=%23d4e8d2&clientId=u298f05d4-9254-4&from=paste&id=Z6GPX&originHeight=558&originWidth=856&originalType=url&ratio=1&rotation=0&showTitle=false&size=374934&status=done&style=none&taskId=u4de11b87-b776-4398-8155-5e5128ff5f9&title=)

## 4.11、索引下推
索引下推是索引下推是 MySQL 5.6 及以上版本上推出的，用于对查询进行优化。索引下推是把本应该在服务层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表。
eg: 首先使用联合索引（name，age），现在有这样一个查询语句：
> select *  from t_user where name like 'L' and age = 17;

这条语句从最左匹配原则上来说是不符合的，只有name用的索引，但是age并没有用到。
不用索引下推的执行过程：
> 第一步：存储引擎利用索引找出name带'L'的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据
> 第二步：存储引擎再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给服务层。
> 第三步：在server层判断age = 17,进行筛选，最终只留下 Lucy 用户的数据信息。

使用索引下推的执行过程：
> 第一步：存储引擎利用索引找出name带'L'的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据
> 第二步：存储引擎根据 age = 17 这个条件，对四条索引数据进行判断筛选，最终只留下 Lucy 用户的数据信息。（注意：这一步不是直接进行回表操作，而是根据 age = 17 这个条件，对四条索引数据进行判断筛选）
> 第三步：将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。

比较二者的第二步我们发现，索引下推的方式极大的减少了回表次数。
![](https://cdn.nlark.com/yuque/0/2023/png/2996398/1680244616456-a170ef69-2f53-4d59-845c-7cbac49b5a7d.png#averageHue=%23fcfaf9&clientId=u1814afea-7d2e-4&from=paste&id=ue9ba048a&originHeight=250&originWidth=976&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0e76ab45-a5f0-400a-b4ec-382a811db0b&title=)
> Extra中 Using index condition代表使用了索引下推

## 4.12、mysql结构
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676734166205-6ab853a2-9331-483e-92cf-8f730684d70e.png#averageHue=%23efebe6&clientId=uf248b5aa-c6a8-4&from=paste&height=484&id=u2e96f0f0&originHeight=677&originWidth=793&originalType=url&ratio=1&rotation=0&showTitle=false&size=68382&status=done&style=none&taskId=u1927bb97-9c23-4e48-ac2f-7f0dda17205&title=&width=567)
MySQL整体的逻辑结构可以分为4层,客户层、服务层、存储引擎层、数据层
**客户层**
客户层:进行相关的连接处理、权限控制、安全处理等操作
**服务层**
服务层负责与客户层进行连接处理、处理以及执行SQL语句等,主要包含连接器、查询缓存、优化器、执行器、存储引擎。触发器、视图等也在这一层
**存储引擎层**
存储引擎层负责对数据的存储和提取，常见的存储引擎有InnoDB、MyISAM、Memory等，在MySQL5.5之后，MySQL默认的存储引擎就是InnoDB,InnoDB默认使用的索引结构就是B+树,上面的服务层就是通过API接口与存储引擎层进行交互的
**数据层**
数据层系主要包括MySQL中存储数据的底层文件，与上层的存储引擎进行交互，是文件的物理存储层。其存储的文件主要有：日志文件、数据文件、配置文件、MySQL的进行pid文件和socket文件等。

## 4.13、数据库查询流程

1. 当客户端的查询语句为select查询语句的时候，如若再查询缓存里面已经查询到了结果，就会直接把查询结果返回给客户端
2. 在查询缓存并没有查询到结果之后，就会走到解析器，在解析器这儿，解析sql，判断是否有语法错误
3. 语法没有问题，走到执行器，执行器先会预处理（检测用户对表的权限，和相应字段有没有），优化器（对sql执行顺序，使用索引等进行优化）
4. 执行器使用引擎提供的接口与存储引擎层进行交互，执行SQL语句，并将结果返回个客户端

## 4.14、sql优化的方案有哪些？

1. 优化表结构

（1）对经常查询的列添加索引，加快查询速度。
（2）尽量避免使用大字段（如 TEXT、BLOB），因为这些字段的读写速度较慢，会影响性能。

2. 优化查询语句

（1）减少查询返回的数据量，避免不必要的 JOIN、子查询等操作。
（2）使用优化的查询方式，例如使用 EXISTS 替代 IN 或 NOT IN。
（3）避免出现索引失效的情况，如WHERE 子句中使用函数或运算符

3. explain 等工具来分析 SQL 查询语句，找出执行计划，确定是否存在性能瓶颈

## 4.15、mysql的explain的详解
EXPLAIN 命令用于SQL语句的**查询执行计划**
```java
EXPLAIN select * from person where dept_id =(select did from dept where dname ='python');
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679319789341-8cecd090-7731-4223-9b27-ab9a3b605275.png#averageHue=%23f9f7f5&clientId=u65a23804-8145-4&from=paste&height=82&id=u45062470&originHeight=82&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7645&status=done&style=none&taskId=u746f8984-6a64-4768-842a-e3ec65c59d5&title=&width=816)

1. id（查询序列号）：从 2 个表中查询，对应输出 2 行，每行对应一个表， id 列表示执行顺序，id 越大，越先执行，id 相同时，由上至下执行
2. select_type（查询类型）：最常见的值包括SIMPLE、PRIMARY、DERIVED 和UNION
> simple：简单查询，没有union和子查询
> primary ：最外层查询 (在存在子查询的语句中，最外面的select查询就是primary)
> derived  ：子查询(在FROM列表中包含的子查询)  EXPLAIN SELECT *FROM (SELECT* FROM person LIMIT 5) AS s
> subquery ：映射为子查询(在SELECT或WHERE列表中包含了子查询)

3. table： 输出的行所用的表
4. type：连接类型，访问类型，表示MySQL在访问表时所采取的方式

性能：性能： null > system/const > eq_ref > ref > ref_or_null   >  range > index >  all 
> null：优化过程中就已得到结果，不用再访问表或索引
> const：在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id=1 就肯定只有一行
> eq_ref：使用有唯一性 索引查找（主键或唯一性索引）
> ref：非唯一性索引访问（select * from user where username = '张三';）
> ref_or_null：该联接类型如同ref类似,结果包含空行
> (上面这五种情况都是很理想的索引使用情况)
> range：索引范围扫描，常见于　<,<=,>,>=,between,in等操作符
> index：索引全扫描，MySQL遍历整个索引来查询匹配的行：（select username from user）
> all：全表扫描

5. possible_keys：可能使用的索引
6. key：实际使用的索引，表示MySQL在执行查询时所使用的索引
7. rows：扫描行数，表示MySQL在执行查询时所扫描的行数。
8. extra：重要的额外信息
> [https://blog.csdn.net/li1325169021/article/details/113925826](https://blog.csdn.net/li1325169021/article/details/113925826)
> （1）Using filesort：排序时没有按照建立复合索引字段的顺序进行，因此产生了外部的索引排序。效率低
> （2）Using temporary：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by
> （3）Using index：select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错
> （4）Using join buffer：表明使用了连接缓存，给驱动表建立索引可解决此问题


## 4.16、MVCC
多版本并发控制，数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。【注意】：只有快照读才会使用MVCC，当前读使用行锁+间隙锁（临键锁Next-Key Locks）实现
它的实现依赖于三个概念：版本链和快照读和ReadView

1. 版本链：多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为版本链(最新记录+undo-log)
> undo log，**回滚日志**，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据. 可以这样认为，当delete一条记录时，undo log 中会记录一条对应的insert记录

![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1681138643616-8b04d0cd-73e4-448e-a9e0-e5215c9002cb.webp#averageHue=%23f4e0c2&clientId=uc1c07bc1-f4f4-4&from=paste&id=uadf71abd&originHeight=425&originWidth=1080&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u48ebeeb9-a1eb-48c5-a8f5-dbad6781c5b&title=)

2. 快照读：读取的是记录数据的可见版本，不加锁，普通的select语句都是快照读
> 当前读：读取的是记录数据的最新版本，显式加锁的都是当前读。如update，delete，select..for update
> 【注意】：只有快照读才会使用MVCC，当前读使用行锁+间隙锁（临键锁Next-Key Locks）实现

3. RedaView：读视图，其实就是一个数据结构，包含四个属性：当前活跃事务编号集合，最小活跃事务编号，预分配事务编号（当前最大事务编号+1），创建者事务编号

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1681140694687-3c414557-8d4c-4e14-a88f-96e340d0a32e.png#averageHue=%23e7e7e7&clientId=uc1c07bc1-f4f4-4&from=paste&height=287&id=uad569d64&originHeight=573&originWidth=1499&originalType=binary&ratio=2&rotation=0&showTitle=false&size=330922&status=done&style=none&taskId=u8727bc1e-4613-4196-ba34-a2a1011a67b&title=&width=749.5)
> 读已提交：在每次执行快照读的时候生成ReadView
> 可重复读：（同一事务）只在第一次使用快照读的时候生成ReadView，后续复用（解决不可重复读）,（但两次快照读之间存在当前读，也会重新生成，所以存在幻读的问题）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1681139612857-20ef580c-3b5b-4a1c-b0ee-04919f0358b6.png#averageHue=%23f9f9f9&clientId=uc1c07bc1-f4f4-4&from=paste&height=474&id=uf353c004&originHeight=948&originWidth=2393&originalType=binary&ratio=2&rotation=0&showTitle=false&size=310540&status=done&style=none&taskId=ue3200b4f-53ac-46b5-8107-a368dc19cc4&title=&width=1196.5)

> 流程：
> 1. 在执行查询操作时生成一个ReadView（注意在读已提交下，每次快照读都生成一个ReadView）
> 2. 遍历版本链，判断是否符合ReadView规则（这个过程其实就是找它最近一次事务提交的数据版本）
> 3. 返回符合规则的数据


## 4.17、行级锁
innoDB通过给索引记录加锁的方式实现行级锁，具体来说实现了三种行锁算法：
**记录锁**：锁定单个行记录的锁（RC,RR都支持）
**间隙锁**：锁定索引记录的间隙，确保索引记录的间隙不变（RR支持）
**next-key锁**：记录锁和间隙锁的组合，同时锁住数据和数据前后范围（RR支持）
> 在RR隔离级别，InnoDB对于记录加锁都是线采用next-key锁，sql中含有唯一索引时，会采用记录锁，仅锁住索引本身而非范围

各种操作加锁的特点：
（1）select...from：采用MVCC而非加锁
（2）select...from for update（在事务完成之前其他事务无法修改它，确保读到的是最新的）：采用next-key，如果有唯一索引，采用记录锁
（3）update,insert,delete同上
# 5、并发编程
## 5.1、进程 线程 并发 并行
**进程**：一个应用代码从磁盘加载到内存，就开启一个进程。进程是资源分配的基本单位
**线程**：一个进程内可以有多个线程，线程就是一个指令流，一条条指令交给cpu执行。线程是执行的基本单位
**并发**：线程轮流使用CPU
**并行**：多核cpu下，多个核同时调度运行线程

## 5.2、线程创建方式

1. 继承Thread类，重写run方法
```java
public class MyThread extends Thread{
    @Override // 实现Thread类，覆写run方法
    public void run() {
        System.out.println("继承Thread方式");
        // ... 具体业务逻辑
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程
    }
}
```

2. 实现Runnable接口，实现run方法
```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("实现Runnable接口方式");
        // ...具体业务逻辑
    }

    public static void main(String[] args) {
        // 创建Runnable实现类对象
        MyRunnable runnable = new MyRunnable();
        // 将runnable作为参数，调用Thread有参构造得到线程
        Thread thread = new Thread(runnable);
        thread.start(); // 启动线程
    }
}

```

3. 实现Callable接口，实现call方法

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况
然后new Thread传入FutureTask
```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("实现Callable接口方式");
        // ... 具体业务逻辑
        return "返回值"; // 返回值，类型和Callable泛型一致，这里用String举例
    }

    public static void main(String[] args) {
        // 创建Callable实现类对象
        MyCallable callable = new MyCallable();
        // 将callable作为参数创建FutureTask对象
        FutureTask<String> futureTask = new FutureTask<>(callable);
        // 将futureTask作为参数创建线程
        Thread thread = new Thread(futureTask);
        thread.start(); // 启动线程
        try {
            // 获取线程执行后的返回值
            String result = futureTask.get();
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
> 三者底层其实都是实现了runnable接口

## 5.3、synchronized原理
synchronized可以修饰静态方法、普通方法、代码块。 能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 在执行完或者出现异常时自动释放锁。 
synchronized关键字的底层原理是Java中的锁机制。在Java中，每个对象都有一个监视器锁（monitor）。当一个线程想要访问一个被synchronized修饰的方法或代码块时，它会尝试获取这个对象的监视器锁。如果这个锁没有被其他线程占用，那么这个线程就可以获取这个锁，并执行synchronized修饰的方法或代码块。如果这个锁已经被其他线程占用，那么这个线程就会进入阻塞状态（waitset，entrylist），直到它能够获取这个锁为止
## 5.4、Lock和Synchronized的区别？

1. lock是一个接口，synchronized是java关键字。 
2. lock是基于CAS+AQS实现的, synchronized是基于Object Monitor实现的
3. lock不会主动释放，需要手动释放锁，synchronized自动释放锁
4. lock功能更丰富，可以通过tryLock()查看是否加锁成功，支持公平锁，非公平锁

## 5.5、死锁的条件
两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去

1. 互斥条件：一个资源一次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

## 5.6、进程间通信方式

1. 管道：道也叫无名（匿名）管道, 管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。 
2. 信号量：为了解决多进程对共享内存访问时的并发问题，设计了信号量以保证多进程并发访问共享变量的安全。信号量实则是一个计数器，拥有原子操作P和V。当信号量值小于等于0之后再进行P操作会把对应线程或进程阻塞
3. 队列：这个就可以发送大量消息了
4. 共享内存 
5. Socket，用于不同机器之间的进程之间的通信

## 5.6、concurrentHashMap实现原理
ConcurrentHashMap的底层数据结构采用的和HashMap一样，即采用“数组+链表+红黑树”的形式。同时，将哈希表分成多个段来实现并发访问。每个段都是一个独立的哈希表，拥有自己的锁，不同的线程可以同时访问不同的段，从而提高了并发性能。在对ConcurrentHashMap进行操作时，只需要锁住对应的段，而不需要锁住整个哈希表，从而避免了线程之间的竞争
查询数据时不会进行加锁（变量值用volatile修饰避免读取到脏数据），所以性能很好

## 5.7、AQS
AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...
**原理：**
它维护了一个volatile int state（代表共享资源）和一个FIFO双向队列（CLH队列，多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到等待队列（entrylist）中。如果调用了锁对象的
AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）
自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了

## 5.8、线程的状态
（1）新建：线程构建完成（但还没被调用start()方法时进入新建状态）
（2）就绪：调用start（）方法进入就绪状态
（3）运行：当得到CPU执行时间之后，线程便真正进入运行状态
（4）阻塞：表示线程阻塞于锁（synchronized）
（5）waiting：主动等待。调用wait，join等方法，不会被分配cpu时间片，等待被显示的唤醒，否则处于无限等待状态。
（6）time waiting：超时等待。在WTING的基础上增加了超时时间,即超出时间自动返回
（7）消亡：突然中断或者子任务执行完毕，线程就会被消亡

## 5.9、ThreadLocal原理
ThreadLocal即线程变量，它用于共享变量在多线程中的隔绝，即每个线程都有一个该变量的副本彼此互不影响也就不需要同步机制了
每个Thread对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。这样就实现了ThreadLocal在一个线程中是共享的，在不同线程之间是隔离的

## 5.10、ThreadLocal存在的问题 - 内存泄漏

1. **弱引用**

正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。弱引用不会增加对象的引用数量。 引用的目标对象称为所指对象（referent）。 因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。

2. **ThreadLocalMap的key使用弱引用原因**

假如使用强引用，当ThreadLocal不再使用需要回收时，发现某个线程中ThreadLocalMap存在该ThreadLocal的强引用，无法回收，造成内存泄漏。因此，使用弱引用可以防止长期存在的线程（通常使用了线程池）导致ThreadLocal无法回收造成内存泄漏。

3. **通常说的ThreadLocal泄露是什么原因**

我们注意到Entry对象中，虽然Key(ThreadLocal)是通过弱引用引入的，但是value即变量值本身是通过强引用引入。
这就导致，假如不作任何处理，由于ThreadLocalMap和线程的生命周期是一致的，当线程资源长期不释放，即使ThreadLocal本身由于弱引用机制已经回收掉了，但value还是驻留在线程的ThreadLocalMap的Entry中。即存在key为null，但value却有值的无效Entry。导致内存泄漏。

4. **怎么避免内存泄露？**

1.Threadlocal自身做了一些处理，在每次调用ThreadLocal的get、set、remove方法时都会执行一个方法，该方法检测整个Entry[]表中对key为null的Entry一并擦除，重新调整索引
2.程序员自身，在代码逻辑中使用完ThreadLocal，都要调用remove方法，及时清理
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1677552835901-c3f7cc4e-e79d-4ab6-be0a-584fdb163c7a.png#averageHue=%23def1ad&clientId=u18225470-eba1-4&from=paste&height=387&id=ub7af4c0b&originHeight=387&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111181&status=done&style=none&taskId=ufb052aa1-a0d8-4832-8664-b2cae6f6861&title=&width=868)

## 5.11、ThreadLocal使用场景
ThreadLocal最常见使用场景可用来解决数据库连接、Session用户管理等。

1. 数据库连接

频繁创建和关闭Connection是一件非常耗费资源的操作，因此需要创建数据库连接池。ThreadLocal能够实现当前线程的操作都是用同一个Connection，保证了事务
```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {  
    public Connection initialValue() {  
        return DriverManager.getConnection(DB_URL);  
    }  
};  
  
public static Connection getConnection() {  
    return connectionHolder.get();  
}
```

2. session用户管理
```java
private static final ThreadLocal threadSession = new ThreadLocal();  
 public static Session getSession() throws InfrastructureException {  
    Session s = (Session) threadSession.get();  
    try {  
        if (s == null) {  
            s = getSessionFactory().openSession();  
            threadSession.set(s);  
        }  
    } catch (HibernateException ex) {  
        throw new InfrastructureException(ex);  
    }  
    return s;  
}
```

3. 避免一些参数的传递

比如我们在底层方法用到某个参数时，不一定要从顶层方法一层层传下去，可以存到ThreadLocal，使用的时候直接去取

## 5.12、线程池的理解

1. 线程池可以有效地管理线程：它可以管理线程的数量,做到线程的服用，可以避免无节制的创建线程,导致超出系统负荷直至崩溃
2. 构造方法的重要参数：corePoolSize（核心线程数）、workQueue（等待队列）、maxinumPoolSize（最大线程数）、handler（拒绝策略）、keepAliveTime（空闲线程存活时间）
3. 线程池流程：

（1）如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
（2）如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务阻塞队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），当线程数小于maximumPoolSize，则会尝试创建新的线程(救急线程)去执行这个任务；
（3）如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理

## 5.13、线程池构造方法参数
通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建

> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，始终存在于线程池中
> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。
> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。
> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等
> 5. workQueue：阻塞队列，用来存放等待被执行的任务。
> 6. threadFactory 线程工厂
> 7. handler：拒绝策略
（1）abortPolicy：抛出异常（默认）
（2）discardPolicy：放弃本次任务
（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代
（4）callerrunPolicy：让调用者运行任务


## 5.14、怎么保证线程安全
保证线程安全的有三种方式：原子类、volatile、锁。
1. 原子类：遵循CAS即“比较和替换”规则,比较要更新的值是否等于期望值,如果是则更新,如果不是则失败（单共享变量）
2. volatile关键字：轻量级的synchronized,在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全（单共享变量）
3. synchronized，java中常用的锁有两种：synchronized+juc包下的lock锁。支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量

## 5.16、如何中断一个正在运行的线程？

1. 使用stop方法强制退出：使用stop()方法强制终止线程，注意，强烈不推荐这种方式，并且该方法已经被标记为过期方法了。（使用stop()释放锁，对锁定的对象进行了解锁，导致数据得不到同步的处理。eg：在一个同步方法里有两个操作，当某个线程执行同步方法完成一个操作时，调用stop（），就会释放锁，导致该同步方法没有原子的执行）
2. 使用interrupt方法中断线程，该方法只是告诉线程要终止，但最终何时终止取决于计算机(就好比，我打电话告诉你不要玩游戏了，但是你什么时候停止玩游戏就是你的事了)；
3. 设置标志位：设置标志位是用到了共享变量的方式，我们了解线程对于变量的操作都是操作的变量副本，而一旦使用volatile关键字修饰后，因为其可见性，变量变更始将终从主存中获取最新值,因此主线程修改变量对新线程可见，在判断共享变量为fasle时，手动抛出异常可中止该线程
```java
public class ThreadDemo3 extends Thread{
    /**共享变量**/
    volatile Boolean heartbeat = true;
    @Override
    public void run() {
        while (true){
           /**判断标志是否为true**/
            if (heartbeat){
                
            }else{
                Throw new RuntimeException()
            }
        }
    }
}
```

## 5.18、为什么AQS用双向队列而不用单向队列？

1. 双向队列可以更高效地支持线程的阻塞和唤醒操作。当一个线程需要被阻塞时，它会被加入到等待队列的尾部，而当它需要被唤醒时，它会被从等待队列的头部唤醒。这种操作比单向队列更加高效，因为单向队列需要遍历整个队列才能找到需要唤醒的线程。
2. 双向队列可以支持锁的公平性。在一个公平锁中，线程必须按照先来先服务的顺序获取锁。双向队列可以维护一个按照时间顺序排列的等待队列，从而实现公平性。而单向队列无法支持这种功能。

## 5.19、Semaphore的作用和原理
Semaphore的作用在于控制并发访问的数量，可以限制同一时间内能够访问共享资源的线程数量。这在一些并发场景中非常有用，例如线程池的大小限制、限流等

Semaphore的实现原理是基于AQS）的，Semaphore内部维护了一个同步状态，表示可用的许可证数量。Semaphore提供了acquire和release两个方法，用于获取和释放许可证。
当一个线程调用acquire方法时，Semaphore会首先判断是否有可用的许可证。如果有，则线程可以直接获取许可证并继续执行。如果没有可用的许可证，则线程将被阻塞，并加入到等待队列中。
当一个线程调用release方法时，Semaphore会将许可证的数量加1，并且唤醒等待队列中的一个线程。被唤醒的线程将尝试再次获取许可证，如果许可证可用，则线程将被唤醒并继续执行。

## 5.20、CountDownLatch原理
CountDownLatch 的原理是通过一个计数器来实现等待机制。在创建 CountDownLatch 对象时，需要指定计数器的初始值，即需要等待的线程数。每当一个线程完成了自己的任务，就会调用 countDown() 方法，使计数器的值减一。当计数器的值为 0 时，等待的线程就会被唤醒，继续执行自己的任务
> 总体来说，CountDownLatch 的底层实现主要依赖于 AQS 的共享模式，通过 acquireShared() 和 doReleaseShared() 方法来实现计数器的减少和线程的等待和唤醒

```java
// 等待三个线程都执行完毕后才能继续执行主线程
public class CountDownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(3);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running...");
            latch.countDown();
        });

        Thread t2 = new Thread(() -> {
            System.out.println("Thread 2 is running...");
            latch.countDown();
        });

        Thread t3 = new Thread(() -> {
            System.out.println("Thread 3 is running...");
            latch.countDown();
        });

        t1.start();
        t2.start();
        t3.start();

        latch.await(); // 等待计数器的值减为 0

        System.out.println("All threads are done. Main thread can continue...");
    }
}
```

## 5.21、java如何停止一个线程

1. stop

这个方法已经过时，不推荐使用（stop方法会立即终止线程，而不管线程当前执行的代码是否已经完成，这可能会破坏线程所持有的锁，导致其他线程无法访问共享资源，从而导致死锁等问题）

2. interrupt

该方法会设置线程的中断状态为true，但并不会立即停止线程的执行。需要在线程的代码中通过检查中断状态来决定是否停止执行
```java
class MyThread extends Thread {
    public void run() {
        // 线程执行某些任务
        while (!Thread.currentThread().isInterrupted()) {
            // 线程执行某些任务
        }
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();

        // 在一定时间后中断线程
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread.interrupt();
    }
}

```

## 5.22、sleep和wait方法的区别？

1. sleep是Thread类的静态方法（可以在任何地方调用），wait是Object类的方法（只能在同步代码块或同步方法中调用）
2. 调用sleep方法后线程会暂停一段时间，然后继续执行，而调用wait方法后线程会一直等待，直到其他线程发出notify或notifyAll通知。
3. 调用sleep方法时不会释放对象的锁，而调用wait方法时会释放对象的锁（进入monitor中waitset等待被唤醒）
> wait()为什么只能在同步方法中调用？因为wait操作的是monitor

## 5.23、java对象的结构是什么样的？

- **对象头（object header）**：有两类信息
   1. markword，如哈希码，偏向线程ID，是否是偏向锁，指向monitor的指针等，将这些数据存储在Mark Word
   2. classword，即对象指向它的类型元数据的指针,Java虚拟机通过这个指针来确定该对象是哪个类的实例
- **实例数据（Instance Data）**：存储的是对象真正有效的信息
- **对齐填充（Padding）**：为了字节对齐，填充的数据，不是必须的（java对象是8字节的整数倍，提高cpu的寻址效率）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1680000430750-252b2091-dbbe-4a10-aa58-0d342aa970bc.png#averageHue=%23c4c2c0&clientId=u117c55cf-edbf-4&from=paste&height=138&id=u2f049cbe&originHeight=138&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15092&status=done&style=none&taskId=u7d268867-6f68-4918-9e60-347f1d2d040&title=&width=506)

## 5.24、java锁升级过程
**偏向锁**
在同步代码中，其实很多时候都是单个线程在跑，如果用重量级锁阻塞操作，涉及上下文切换和cpu内核态和用户态的频繁切换，开销会很大，所以引入偏向锁，他偏向第一个访问对象的线程，线程id记录在锁对象的对象头中。该线程再次访问时，直接进入同步块，不需要进行额外的加锁操作。如果不是，则说明存在竞争，偏向锁会自动升级为轻量级锁

**轻量级锁**
有时候会存在多个线程访问同步代码的情况，但每个线程执行的时间很短，这时候没必要阻塞等待，通过自旋来等待。使用CAS（Compare and Swap）操作来尝试获取锁，如果成功，则直接进入同步块。如果失败，则自旋去获取锁，达到自旋次数（1.6前默认10次，1.6次数由jvm动态控制），轻量级锁会自动升级为重量级锁。

**重量级锁**
并将当前线程加入到锁对象的阻塞队列（entrylist）中。然后，JVM会将当前线程挂起，直到其他线程释放锁对象，JVM会从阻塞队列中选择一个线程唤醒尝试竞争锁
> synchronized是非公平锁：（1）阻塞队列中唤醒的线程是随机的，并不是按照入队时间 （2）即使被唤醒，也有可能被新来的没有加入阻塞队列的线程抢占


## 5.25、并发编程的特性

1. 原子性：原子性是指一个操作不可分割，不可中断，一个线程在执行时，另一个线程不会影响到他

如何保证：（1）synchronized （2）CAS （3）Lock锁 （4）ThreadLocal

2. 可见性：因为本地内存和主内存的存在，关联到cpu层面其实就是cpu的三级缓存和主内存，一个线程在读取数据时，先从本地内存查询，如果没有，再从主存中查，然后复制到本地内存进行操作，操作完后，会将修改后的数据刷新回主内存。因为现在cpu都是多核的，所以存在多个线程同时操作一个共享变量，但是本地内存中的修改对于其它线程是不可见的

如何保证：（1）volatile（2）final

3. 有序性：序执行的顺序与代码编写的顺序一致，cpu为了提升执行效率，会进行执行重排

       如何保证：（1）volatile

## 5.26、什么是CAS？会有什么问题？
compare and swap，比较交换，他是一条cpu并发原语（原语代表这个操作是原子性的）。作用就是替换内存中某个位置的值时，首先查看内存中的值与预期值是否一致，如果一致，执行替换操作
**存在的问题**：ABA, 线程1读取内存某个位置的值为A，线程2读取并将数据修改为B，然后另一个线程又将B修改回A，线程1进行cas时发现内存中值仍为A，所以cas成功，但事实上A是经过修改的
**解决**：AutomicStampedRefence，除了比较值，还会比较版本信息
**思考**：在实际的业务场景中，因为我们常常关注的是 A 的值本身，所以ABA问题对我们的业务逻辑并没有什么影响

## 5.27、java中锁的分类有哪些

1. **可重入锁和不可重入锁**

Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入
重入：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。
不可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁

2. **乐观锁和悲观锁**

Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁
Java中提供的CAS操作，就是乐观锁的一种实现
悲观锁：获取不到锁资源时，会将当前线程挂起 (进入BLOCKED、WAITING)，线程挂起会涉及到用户态和内核态的切换，而这种切换是比较消耗资源的。
乐观锁：获取不到锁，再让CPU调度，重新尝试获取锁资源。Automic原子类中，就是基于CAS乐观锁实现的

3. **公平锁和非公平锁**

synchronized是非公平锁
ReentrantLock和ReentrantReadWriteLock可以实现公平锁和非公平锁

4. **互斥锁和共享锁**

Synchronized，ReentrantLock是互斥锁
ReentrantReadWriteLock有互斥锁也有共享锁（写互斥读共享）
互斥锁：同一时间，只有一个线程持有当前互斥锁
共享锁：同一时间点，多个线程可以共同持有

## 5.28、ReentrantLock底层原理
ReentrantLock主要利用CAS+AQS队列来实现，它是一种独占锁、可重入锁，它支持公平锁和非公平锁模式。
ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁状态（int state）。如果此时已经有线程占据了锁（state>=1）（或者在公平模式下队列中有等待的线程），那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。

非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
公平锁：线程在请求锁的时候，依次入队，严格按照先来后到的顺序分配锁。

## 5.29、ReentrantReadWriteLock原理
读写锁，主要用于读多写少的场景，读读不互斥，涉及到写操作互斥.
它也是基于cas+aqs实现的，state字段的高16位代表读锁，低16位代表写锁
写锁的值代表重入次数，读锁因为是共享的，state代表持有的线程数， 该线程重入次数在ThreadLocal中保存

## 5.30、jdk提供了哪些线程池创建的方式
JDK中基于Executors提供了很多种线程池

1. newFixedThreadPool：存放固定数量的线程，阻塞队列使用了LinkedBlockingQueue，是一个无界队列，因此永远不可能拒绝任务

**场景**：这种线程池适合用在稳定且固定的并发场

2. newSingleThreadExecutor： 单个线程的线程池，核心线程和最大线程数都是1，阻塞队列也是使用LinkedBlockingQueue无界队列。因为只有一个线程执行，保证了执行顺序

**场景**：适合那些需要按序执行任务的场景

3. newCachedThreadPool：缓存的线程池，核心线程数0，最大线程数是最大整数，keepAliveTime为60s，阻塞队列是SynchronousQueue，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他

**场景**：只要有任务提交到线程池，必然有线程可以处理（但不建议使用，因为会无限制创建线程）

4. newScheduledThreadPool：周期性执行任务，本质还是一个固定数量的线程池，只不过在线程池基础上实现了定时任务，原理是基于DelayQueue实现延迟执行，执行完毕后再扔回阻塞队列，实现周期性执行

## 5.31、线程池状态

1. RUNNING状态：线程池创建后，初始状态为RUNNING。
2. SHUTDOWN状态：当调用线程池的shutdown()方法时，线程池进入SHUTDOWN状态。此时线程池不再接受新的任务，但会执行已经提交的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。
3. STOP状态：当调用线程池的shutdownNow()方法时，线程池进入STOP状态。此时线程池不再接受新的任务，并且会中断正在执行的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。
4. TIDYING状态：当线程池处于SHUTDOWN或STOP状态时，所有任务都执行完毕后，线程池会进入TIDYING状态。在此状态下，线程池会进行清理工作，如关闭线程池中的所有线程等。当清理工作完成后，线程池会转换到TERMINATED状态。
5. TERMINATED状态：线程池处于TERMINATED状态时，表示线程池已经完全终止，所有任务已经执行完毕并且清理工作也已经完成。此时线程池不再能接受新的任务。

# 6、redis
## 6.1、redis数据结构

1. 基本数据结构

字符串(String)、哈希(Hash)、列表(List)、集合(set)、有序集合(zset)。 
**String**：String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化的数据、JSON化的对象甚至是图片。 
> 底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 '\0'，而在Redis中\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取

**List**：List是字符串列表，按照插入的顺序排序，元素可以重复，你可以添加一个元素到列表的头部或者尾部，底层是一个链表结构。
> list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist
>  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大

**Set**：Set是一个无序不重复的集合
> 底层是hashtable和inset

**Hash**：Hash是String类型的filed和value的集合，适合用于存储对象。
> 底层是ziplist也可以是我们的hashtable

**Zset**：Zset和set一样也是String类型元素的集合，且不允许有重复的元素，但不同的是Zset的每个元素都会关联一个分数，分数可以重复，Redis通过分数来为集合汇总的成员进行从小到大的排序。 
> 底层是一个ziplist和**skiplist**


2. 特殊数据结构

**bitmap：**是一种实现对位的操作的'数据结构'，在数据结构加引号主要因为：Bitmap 本身不是一种数据结构，底层实际上是字符串，可以借助字符串进行位操作。数组的每个单元只能存储 0 和 1，数组的下标在 Bitmap 中叫做偏移量 offset
## 6.2、redis持久化方式

1. **rdb**

把当前内存中的快照写入磁盘
**实现方式：**
（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用
（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题
（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000

2. **aof**

以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）

|  | rdb | aof |
| --- | --- | --- |
| 占用存储空间 | 小（数据级） | 大（指令级） |
| 恢复速度 | 快 | 慢（需要执行指令） |
| 数据安全性 | 可能会丢失最后一次持久化后的数据 | 根据策略决定 |

> aof策略：
> （1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）
> （2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据
> （3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的


3. **混合模式**

Redis 4. 0之后新增的方案，混合持久化是结合了 RDB 和 AF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启速度快，又能降低数据丢失的风险
## 6.3、redis淘汰策略
**定时删除**
方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作
优缺点：1.节约内存,到时就删,快速释放掉不必要的内存占用 2.CPU压力变大,无论CPU此时负载量多高,均占用CPU
**惰性删除**
方式：数据到期时不做删除,等下次访问时进行删除
优缺点：1.节约cpu性能  2.长期大量占用内存
**定期删除**
方式：redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除
> Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为
> hz 它的默认值是 hz 10。
> 注意:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。

> 删除流程：
> （1）从过期字典随机取20个键
> （2）删除这20个键中过期的键
> （3）如果过期key的比例超过25%，重复步骤1

优缺点：每秒花费固定cpu资源维护内存

## 6.4、redis如何实现分布式锁
在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境,而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁

1. 通过`set...nx...`命令,将加锁、过期命令编排到一起,把他们变成原子操作。完整命令：set key random-value nx ex seconds
> 其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令。
> 一般代指Redis中对set命令加上nx参数进行使用

> （1）nx  ex 是set指令的两个参数： ex过期时间    nx只有key不存在时设置新的key/value
> （2）key设置成随机数，避免一个线程过期时间内没释放掉锁，过期后有另一个线程获取到锁，该线程执行完后释放掉另一个线程获取的锁
> （3）设置过期时间（EX）作用：如果客户端忘记解锁,那么这种情况就很有可能造成死锁
> （4）NX的作用：避免重复获取锁


2. 解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。另外判断,释放这两步需要保持原子性，所以通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的
> if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end

> **这里为什么要用原子操作？**
> 主要是怕误将其他客户端的锁解开。比如客户端A加锁，一段时间之后客户端A解锁，在进入unlock后执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除

```java
import redis.clients.jedis.Jedis;

public class RedisLock {
    private Jedis jedis;

    public RedisLock(Jedis jedis) {
        this.jedis = jedis;
    }

    /**
     * 尝试获取锁
     * @param lockKey 锁的名称
     * @param requestId 请求标识，用于释放锁
     * @param expireTime 锁的过期时间
     * @return 是否成功获取锁
     */
    public boolean tryLock(String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, "NX", "EX", expireTime);
        if ("OK".equals(result)) {
            return true;
        }
        return false;
    }

    /**
     * 释放锁
     * @param lockKey 锁的名称
     * @param requestId 请求标识，用于判断是否是同一个客户端
     * @return 是否成功释放锁
     */
    public boolean releaseLock(String lockKey, String requestId) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        // jedis.eval是Jedis客户端提供的一个用于执行Lua脚本的方法
        Long result = (Long) jedis.eval(script, 1, lockKey, requestId);
        if (result == 1) {
            return true;
        }
        return false;
    }
}

```
> 另外可以通过Redisson框架，它的底层原理其实也是这个setnx


## 6.5、redis与数据库如何保持双写一致性？
更新数据库和更新redis不是一个原子操作。所以根据业务场景有两种方案：

1. 保证最终一致性（可以接受数据短期不一致）

先更新数据库，再更新redis。第二步更新redis失败的请求异步写入mq消息队列，利用mq的重试机制进行更新
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679227622125-f3d54dc1-93ef-4b79-936a-d452094a32ad.png#averageHue=%23eef9fa&clientId=u6b9b4d54-8d47-4&from=paste&height=396&id=u8e4b224b&originHeight=509&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134774&status=done&style=none&taskId=u81e57ee2-caba-4777-837e-637f12e6355&title=&width=596)

2. 强一致性保证

使用读写锁，在数据更新的时候，其它任何请求都无法访问缓存中的数据
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679227590591-d848dbe5-4ef0-4c08-8239-cd6043ad91bc.png#averageHue=%23f0fafa&clientId=u6b9b4d54-8d47-4&from=paste&height=297&id=uad8553b6&originHeight=297&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76361&status=done&style=none&taskId=uc58241c3-765d-40d2-b2b8-600c1b4dc0c&title=&width=610)
## 6.6、redis是单线程的吗
Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行
> redis为什么快？（1）单线程避免了线程竞争和切换带来的开销（2）基于内存，所以读写都比较快 （3）采用多路复用非阻塞I/O


## 6.7、如何实现redis高可用

1. **主从复制**：写一定是在主服务器上，然后主服务器同步给从服务器。

缺点：当主服务器挂掉的时候，不能自动切换到从服务器上。主从服务器存储数据一样，内存可用性差。
优点：在一定程度上分担主服务器读的压力。

2. **哨兵模式**：构建多个哨兵节点监视主从服务器，当主服务器挂掉的时候，自动将对应的从服务器切换成主服务器。

优点：实现自动切换，可用性高。
缺点：主从服务器存储数据一致，内存可用性差。还要额外维护一套哨兵系统，较为麻烦。

3. **集群模式**：采用无中心节点的方式实现。多个主服务器相连，一个主服务器可以有多个从服务器，不同的主服务器存储不同的数据。

优点：可用性更高，内存可用性高。

## 6.8、说说缓存穿透、击穿、雪崩的区别
缓存击穿：一份热点数据，在它缓存失效期间，大量的请求直接命中存储层。 
> 解决方法：
> 1.设置热点数据永不过期的策略。
> 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了。

缓存穿透：某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机。 
> 解决方法：
> 1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。
> 2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值。 

> 布隆过滤器：它是一种类似哈希的数据结构，通过这个数据结构，可以快速的插入和查询，确定某个事件一定不存在或可能存在。特点是占用空间少，缺点是返回的结果是概率性
> 当一个元素加入集合时，就通过K个hash函数将这个映射成一个位数组中的K个点，把它们置为1。当查询时，只要检查这些点是否全为1，就能判断集合中是否可能存在。
> 如果k个点有任何一个0，则被检元素一定不在。如果都是1，则很可能存在，这个期望概率是可以设置

缓存雪崩：由于某些原因，中间层的缓存层不能提供服务，大量的请求直达数据存储层，导致宕机。 
> 解决方法：
> 1.设置多级缓存，在存储层之前加上一层本地缓存。
> 2.构建高可用的redis缓存，部署多个redis实例，个别不能用，也不至于宕机。


## 6.9、redis内存淘汰策略
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据
> LRU：淘汰最长时间没有被使用的
> LFU：一定时间内使用频次越低的
> random：随机
> ttl：越早过期的数据

| **淘汰策略名称** | **策略含义** |
| --- | --- |
| noeviction | 默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外） |
| allkeys-lru | 从所有数据中根据 LRU 算法挑选数据淘汰 |
| volatile-lru | 从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰 |
| allkeys-random | 从所有数据中随机挑选数据淘汰 |
| volatile-random | 从设置了过期时间的数据中随机挑选数据淘汰 |
| volatile-ttl | 从设置了过期时间的数据中，挑选越早过期的数据进行删除 |
| allkeys-lfu | 从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用） |
| volatile-lfu | 从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用） |



# 7、mq
## 7.1、mq的用处和缺点
**优势：**
（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单
（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度
（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。
**劣势：**
（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用
（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？
（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性

## 7.2、rabbitmq组件

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675740684760-d44e0791-b1da-483d-9274-a2e68714e7c7.png#averageHue=%23d3d35b&clientId=u1c130bb5-33d5-4&from=paste&height=268&id=u515cf7a8&originHeight=268&originWidth=893&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60804&status=done&style=none&taskId=ucf018e58-a4ed-4020-9313-abf54159de2&title=&width=893)

（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。
（2）Connection：连接，应用程序与Server的网络连接，TCP连接。
（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
> 如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接
> Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销

（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。
（6）Queue：消息队列，用来保存消息，供消费者消费
（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。
（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”

## 7.3、rabbitMQ交换机类型

1. Direct Exchange（直连交换机）

根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661233986129-afce563d-98b7-4559-bc81-bffb856d29ef.png#averageHue=%23f7e1e1&clientId=u1f2092d6-850c-4&from=paste&height=144&id=u22753071&originHeight=144&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15620&status=done&style=none&taskId=uac52e483-773c-4871-81de-6ee3aac512d&title=&width=379)

2. Fanout Exchange

该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么
> 如果想让多个消费者消费到数据必须不指定queues，指定交换机

```java
@RabbitListener(bindings = @QueueBinding(

        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生

        exchange = @Exchange(value = "business_rrpc_exchange",type = ExchangeTypes.FANOUT)

))

```

3.  Topic Exchange（主题交换机）
将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.*  ” 只会匹配到“abc.def”。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661234502774-bcf2c312-eb4a-4b08-bdf4-04d1e00120c6.png#averageHue=%23f7e2e2&clientId=u1f2092d6-850c-4&from=paste&height=145&id=ufa6d9153&originHeight=145&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16576&status=done&style=none&taskId=udb8c02a0-8915-45bc-94a0-57fc472954b&title=&width=397)

4. Headers Exchanges（头交换机）

与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列
> 匹配规则x-match有下列两种类型：
x-match = all ：表示所有的键值对都匹配才能接受到消息
x-match = any ：表示只要有键值对匹配就能接受到消息

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661235159094-3892f748-0b85-4434-ae94-8312b03666ee.png#averageHue=%23fcf3f2&clientId=u1f2092d6-850c-4&from=paste&id=ud65c1929&originHeight=225&originWidth=587&originalType=url&ratio=1&rotation=0&showTitle=false&size=25703&status=done&style=none&taskId=uc66d4e00-7f87-4157-b04d-eaf97a4ed47&title=)

## 7.4、rabbitMQ工作模式
> 简单模式和工作队列模式都是点对点模式。其他的都是发布与订阅模式

1. 简单模式

一个生产者对应一个消费者。这个模式下一个发生一个接收，不用考虑交换机。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675751154663-d967a570-e70e-472e-9d91-b702900a369b.png#averageHue=%23f9dede&clientId=u1c130bb5-33d5-4&from=paste&height=123&id=uab8c94c4&originHeight=123&originWidth=357&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8784&status=done&style=none&taskId=u600ec559-c0f1-42a0-a353-2a4db284d6f&title=&width=357)
> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理

```java
@Component
public class MessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void send(String message) {
        rabbitTemplate.convertAndSend("simple.queue", message);
    }
}

@Component
public class MessageReceiver {
 
    @RabbitListener(queues = "simple.queue")
    public void receive(String message) {
        System.out.println("Received message: " + message);
    }
}

```

2. 工作队列模式

一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息。谁先拿到谁消费
> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度


![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675751171601-c5a2995a-018e-4f3e-9165-9af05c8ffaae.png#averageHue=%23f8dada&clientId=u1c130bb5-33d5-4&from=paste&height=146&id=u0cbbec5c&originHeight=146&originWidth=382&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14008&status=done&style=none&taskId=u4a973303-a770-4b77-92bc-a9f98b94856&title=&width=382)

3. 发布订阅模式

生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息
![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661236597993-e6418afb-21a5-4198-a6d8-1ac88d7f6e68.png#averageHue=%23f7dada&from=url&id=GMqUi&originHeight=164&originWidth=391&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
```java
// 生产者
@Component
public class MessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void send(String message) {
        rabbitTemplate.convertAndSend("fanout-exchange", "", message);
    }
}
// 消费者
@Component
public class MessageConsumer {

    @RabbitListener(queues = "queue-1")
    public void receiveFromQueue1(String message) {
        System.out.println("Received message from queue-1: " + message);
    }

    @RabbitListener(queues = "queue-2")
    public void receiveFromQueue2(String message) {
        System.out.println("Received message from queue-2: " + message);
    }
}

// 交换机绑定队列
@Configuration
public class RabbitMQConfig {

    @Bean
    public FanoutExchange fanoutExchange() {
        return new FanoutExchange("fanout-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, FanoutExchange fanoutExchange) {
        return BindingBuilder.bind(queue1).to(fanoutExchange);
    }

    @Bean
    public Binding binding2(Queue queue2, FanoutExchange fanoutExchange) {
        return BindingBuilder.bind(queue2).to(fanoutExchange);
    }
}



```

4. 路由模式

生产者发送的消息是以key-value的形式，当消息进入交换机，交换机根据key的不同，将其分配到不同的队列。消费者通过Channel声明一个队列时，需要绑定给队列绑定一个key和一个交换机。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661238576118-08d05cd0-ec41-4db8-922a-4eea1ae99e16.png#averageHue=%23f6e4e4&clientId=u1f2092d6-850c-4&from=paste&height=148&id=u15bd2eac&originHeight=148&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22813&status=done&style=none&taskId=uee97833f-f94d-46df-9cdb-0cb79ad29ea&title=&width=396)
```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public DirectExchange directExchange() {
        return new DirectExchange("direct-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, DirectExchange directExchange) {
        return BindingBuilder.bind(queue1).to(directExchange).with("routing-key-1");
    }

    @Bean
    public Binding binding2(Queue queue2, DirectExchange directExchange) {
        return BindingBuilder.bind(queue2).to(directExchange).with("routing-key-2");
    }
}

```



5. 主题模式

主题模式从某种意义上也算是一种路由，只不过它可以匹配多种符合条件的队列。Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符
> *可以代替一个单词，#代表没有和多个单词

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661239369166-9fb94bca-0467-4982-8b2e-4528148a35a6.png#averageHue=%23f6e5e1&clientId=u1f2092d6-850c-4&from=paste&height=185&id=udc9a98eb&originHeight=185&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65300&status=done&style=none&taskId=u289c5cfc-f051-4301-ae36-55835a1b2c3&title=&width=561)
```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public TopicExchange topicExchange() {
        return new TopicExchange("topic-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, TopicExchange topicExchange) {
        return BindingBuilder.bind(queue1).to(topicExchange).with("topic.key.*");
    }

    @Bean
    public Binding binding2(Queue queue2, TopicExchange topicExchange) {
        return BindingBuilder.bind(queue2).to(topicExchange).with("topic.#");
    }
}

```

## 7.5、如何保证消息不丢失？

1. **生产者->broker**

confirmCallback 确认模式。(无论成功失败都有返回)
（1）在配置文件中开启消息确认模式
（2）通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理

2. **broker中**

消息回退：消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）
> rabbitTemplate.setMandatory(true)

持久化：保证重启过程中，交换机和队列也是持久化的

3. **broker ->消费者**

消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除

（1）rabbitmq默认的是自动ack，无需添加其他配置
若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。
若消费过程中出现异常，则超过ack心跳时间，会触发重试消费

（2）手动ack
开启方式简单，只需要放开此配置即可
> acknowledge-mode: manual #设置消费端手动 ack

## 7.6、如何保证消息的顺序性
出现无序的场景：一个队列有多个消费者消费的时候，这些消息被多个线程并发消费，并发是不能保证顺序的

1. mq层面：拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)
2. 应用层层面：消息实体中增加：版本号 & msgid & parent_msgid，通过 parent_msgid 判断消息的顺序（需要全局存储，记录消息的执行状态）
## 7.7、死信队列
死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？

“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：
（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue 属性被设置为false。
（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。
（3）消息队列的消息数量已经超过最大队列长度。
  那么该消息将成为“死信”。
“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。

## 7.8、如何实现延迟队列（DLX 实现）
实现思路： 我们可以把死信队列就当成延迟队列
假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 routing_key，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。

## 7.9、emqx & MQTT	
mqtt  和 emqx 的关系类比于amqp和 rabbitmq，是协议和实现的关系
mqtt开销很小，协议交换最小化，以降低网络流量。所以非常在物联网领域（嵌入式设备的运算能力和带宽都相对薄弱）

## 7.10、如何保证消息不被重复消费（幂等性）
> 场景：消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，重新发送，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；


> 所谓幂等性，就是数据无论操作多少次，所产生的影响跟执行一次是一样的，比如对于读操作来说，无论读取多少次数据，都跟读取一次的数据是一样的，所以读操作是一个幂等性操作，而添加操作，添加多次会有多条记录，因而写操作则是非幂等性操作

可以通过给消息的某一些属性设置唯一约束，比如增加唯一uuid，添加的时候查询是否存对应的uuid，存在不操作，不存在则添加，那样对于相同的uuid只会存在一条数据。（注：但需要保证查询跟添加的操作必须是原子性操作，可以使用setnx保证原子）
```java
 boolean send = jedisClient.setnx(channel, uuid) == 1;
if(send){
     // TODO 开始发送短信
}
```

## 7.11、MQTT
MQTT是一种轻量级的、基于发布/订阅模式的消息传输协议，主要用于物联网.MQTT协议的设计非常简单,所以带宽的开销很小，很适合小型的嵌入式设备。MQTT显示上没有rabbitmq中交换机，队列的概念，生产者将消息发布到一个主题（Topic）中，而消费者则订阅该主题，以便接收相应的消息，从而实现消息的传递和交互
# 8、网络
## 8.1、长连接和短连接的区别？
HTTP的长连接和短连接本质上是TCP长连接和短连接
**长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。直到服务器超时自动断开链接，或者客户端主动断开链接
**短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。
> 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。
> Http长连接 和 TCP长连接的区别在于: TCP 的长连接需要自己去维护一套心跳策略。，而Http只需要在请求头加入keep-alive:true即可实现长连接


## 8.2、cookie和session的区别？

1. 存储位置：cookie存储在客户端浏览器中，session存储在服务器端。
2. 安全性：cookie可以被客户端修改和窃取，因此不适合存储敏感信息。而session存储在服务器端，只有服务器可以访问它，因此更加安全。
3. 存储容量：cookie的存储容量有限，通常只能存储少量的数据。而session可以存储大量的数据，因为它存储在服务器端。（具体容量看设置，cookie默认4kb，session几十兆）
4. 过期时间：cookie可以设置过期时间，当过期时，浏览器会自动删除cookie。而session在用户关闭浏览器时会自动过期。

总的来说，cookie适合用于存储少量的非敏感信息，如用户偏好设置、购物车信息等；而session适合用于存储大量的敏感信息，如用户登录状态、权限等
# 9、dubbo
## 9.1、dubbo和springCloud区别
两者都是现在主流的分布式框架，但却存在不少差异：

- **生态环境不同：** SpringCloud定位为微服务架构下的一站式解决方案（网关，分布式配置，服务跟踪）；Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用和治理
- **调用方式：** SpringCloud是采用Http协议做远程调用；Dubbo是基于RPC调用
- **组件差异比较多**，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper

![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1675996970042-0552f61a-26e1-402c-9dc1-642431c222ab.webp#averageHue=%23eff3f2&clientId=ued21274a-04e3-4&from=paste&id=ue20f9ce5&originHeight=341&originWidth=771&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u280d4e8b-f356-4658-9572-330db8e00f5&title=)

## 9.2、dubbo支持哪些协议
**1、dubbo 默认协议：**

- 单一 TCP 长连接，Hessian 二进制序列化和 NIO 异步通讯
- 不适合传送大数据包的服务

**2、rmi 协议：**

- 采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式
- 对传输数据包不限，消费者和传输者个数相当

**3、hessian 协议：**

- 底层 Http 通讯，Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现
- 通讯效率高于 WebService 和 Java 自带的序列化
- 适用于传输数据包较大，提供者比消费者个数多，提供者压力较大

**4、http 协议：**

- 基于 http 表单的远程调用协议，短连接，json 序列化
- 对传输数据包不限，不支持传文件

**5、webservice 协议：**

- 基于 Apache CXF 的 frontend-simple 和 transports-http 实现，短连接，SOAP文本序列化
- 可与原生 WebService 服务互操作
- 适用于系统集成、跨语言调用

**6、thrift 协议：**

- 对 thrift 原生协议 [2] 的扩展添加了额外的头信息
- 使用较少，不支持传 null 值

**7、基于 Redis实现的 RPC 协议**
**8、基于 Memcached 实现的 RPC 协议】**

## 9.3、dubbo负载均衡策略
```java
dubbo:
  provider:
    loadbalance: roundrobin
```
> 也可以在注解上进行配置
> @Service(version = "${product.service.version}",loadbalance="roundrobin")

1. RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的**默认**负载均衡策略。
2. RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。
3. LeastActiveLoadBalance: 最小活跃数负载均衡，活跃数也就是dubbo的连接数，每当收到一个请求活跃数+1，结束请求活跃数-1，假设如果多台机器的连接数是相同的，如果一台机器性能比较好，处理请求比较快那么活跃数减少的就快，活跃数就少。所以活跃数少的就会获取到的请求会变多，这样就可以合理的使用性能不同的机器了
4. ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。

## 9.4、dubbo集群容错
| **类型** | **负载均衡** | **备注** |
| --- | --- | --- |
| failover | 会 | 失败后会尝试调用其他服务器实例，默认尝试2次， 可以通过设置retries来设置次数。这是dubbo默认的容错机制，由于常常可能因为超时待原因触发异常但远程服务已经完成操作，所以这个类型不应就在数据更新的操作 |
| failfast | 会 | 有异常立即返回，不做尝试，我认为可以用在数据更新上，以保证数据的一致性 |
| fastsafe | 会 | 有异常会直接忽略，为的是保证调用方接下来的正常运行，一般用于日志收集等与正常流程无关的操作 |
| failback | 会 | 失败后会将任务丢到失败队列中，并会异步再次尝试 |
| forking | 否 | 同时调用多个服务，取最先返回的结果，可以通过forks设置最大并行数，这比较浪费资源 |
| broadcast | 否 | 调用所有可用的服务，任意一个有错都会返回异常 |
| Mock | 否 | 调用失败时返回伪造的响应结果 |

> 一般在@DubboService或@DubboReference指定cluster即可，如
@DubboService(cluster = “failover”) //默认重试2次


## 9.5、dubbo节点角色

1. Container：服务运行容器。
2. Provider：暴露服务的服务提供方。
3. Consumer：调用远程服务的服务消费方。
4. Registry：服务注册与发现的注册中心。
5. Monitor：统计服务的调用次数和调用时间的监控中心。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676255772897-ef7e967d-0649-47fc-9619-df682d81623d.png#averageHue=%23fdfdfd&clientId=u8e7e2608-ecdb-4&from=paste&height=436&id=ued12782e&originHeight=824&originWidth=1060&originalType=url&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=u97be041b-5627-4a7c-bd1d-83152ce3e7b&title=&width=561)
## 9.5、dubbo调用过程

1. 服务容器 Container 负责启动加载运行服务提供者 Provider。根据配置中的 Registry 地址连接 Registry，在 Registry 注册自己提供的服务。
2. Consumer 在启动时，根据配置文件中的服务引用信息，连接到 Registry，向 Registry 订阅自己所需的服务。
4. Registry 根据服务订阅关系，返回 Provider 地址列表给 Consumer。如果有变更，Registry 会基于长连接推送最新的服务地址信息给 Consumer。
5. Consumer 调用远程服务时，基于负载均衡算法，从缓存的 Provider 地址列表中选择一台进行跨进程调用服务
6. 服务 Provider 和 Consumer，会在内存中记录调用次数和调用时间，每分钟发送一次统计数据到 Monitor。

# 10、springCloud
## 10.1、如何保证分布式事务一致性？

1. 首先是设计方案尽可能规避分布式事务的场景（相似的业务放在一起，不要过度的拆分）
2. 根据业务场景，选择使用柔性事务（ap）还是强事务(cp)

如果可以允许消息存在一段时间不一致，只要保证最终一致性，可以用本地消息表来做。如果要保证一致性，可以用2pc，具体实现方案有阿里的seata

3. 本地消息表（柔性事务）

不去同步的调用，先将要请求的消息插入到本地的消息表中，消息状态为正在处理，起一个定时任务去查询消息表，将正在处理的消息发送到消息队列，B中消息处理完后，向一个return队列发送一个成功的消息，A订阅了该消息队列，收到成功的消息后将状态该为处理完毕。（被调用方应保证幂等性，如库存系统在减库存前先查流水表，看该订单是否扣过库存，扣过就不执行）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679844537244-b3de5d9e-7e6e-4b74-9345-cbb66fedcb80.png#averageHue=%23f5f5f5&clientId=u051b1bd0-acdc-4&from=paste&height=454&id=u41a8bcd9&originHeight=454&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131665&status=done&style=none&taskId=u5de36835-b151-439d-8526-90f53f7550e&title=&width=1389)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679845311357-39625a82-0e3e-4795-bd7e-5643f203abe8.png#averageHue=%23f0f0f0&clientId=u051b1bd0-acdc-4&from=paste&height=204&id=uf58d5a6a&originHeight=204&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38032&status=done&style=none&taskId=u4db46ad2-afb8-4c97-abaf-64c4c34f5eb&title=&width=642)

## 10.2、架构的演进
单体-垂直-分布式-SOA-微服务 （详情看springcloud笔记开头部分）

## 10.3、分布式和微服务有什么关系？
我理解的分布式是一种系统架构，指一个系统由多个独立的组件组成，这些组件可以在不同的物理位置上运行，从而提升了系统的性能
而微服务可以看作是分布式的一种实现方案。分布式实现方案有soa，基于rpc远程调用（dubbo），微服务（springcloud）

# 11、场景题
## 11.1、两个50亿url的文件如何找出共同的url
**问题：**给A，B两个文件，各存放50亿条URL，每条URL占用64个字节，内存限制为4G，找出A，B中相同的URL。

**分析：**可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法

**方案：**分治思想

1. 分治思想遍历文件A，对每个url求hash(url)%N，然后将取得的值分布到N个小文件中，每个小文件可以放在内存中。
2. 遍历文件B，采取和A相同的方式将url存储到N个小文件中.
3. 分布取两个小文件，把一个小文件加入hashset，然后遍历另一个，如果url在哈希表，则为共同url，汇总到结果中。
> 有可能出现哈希碰撞，可以采用多个哈希函数减少碰撞概率。


## 11.2、如何从1000w记录中，找出最热门的10个记录？
> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前一个日志文件中有一千万个记录 (这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过了百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门) ，请你统计最热门的1口个查询串，要求使用的内存不能超过1G


> 1000万条记录，每条记录最大为255Byte，那么日志文件最大有2.5G左右（超过1G）
> 如果去重复有100万条记录，占用250M内存。那么我们可以考虑将这些无重复的记录装入内存
> 这时我们需要一种数据结构，这种数据结构即能够存储查询串，又能存储查询串的出现次数。

    第一步、先对这批海量数据预处理，用hashmap存储，key为内容，value为出现次数 。O（N）
    第二步、创建一个长度为10的小根堆，遍历hashmap，如果MinHeap未满，那么往MinHeap中插入这个键值对，如果MinHeap满了，则比较遍历到的元素的count值堆顶的count，如果遍历到元素的count大于堆顶count值，删除堆顶元素，插入当前遍历到的元素。遍历完整个hashmap以后，在MinHeap中存储的就是最热门10个查询串

## 11.3、20亿个用户统计登录状态
> 20亿的用户，频繁改变数据库，io极大，数据库性能可能会被拖垮。
> 考虑使用redis，如果用set存储，登录存入set，退出删除。一个用户按4字节，10亿个用户4G内存，太大

我们使用redis的bitmap来进行存储。
setbit命今 语法:setbit key offset value  设置或修改key上的偏移量 (offset) 的位 (value) 的值
10亿用户，1个用户只占用1bit 相比于set占用的4字节，优化了了32倍那么节省后的内存为125MB。
优点:查找效率高。
缺点: 结果数据不能重复，数据如果太过分散会造成浪费，只有数据密集才可以

# 12、数据结构和算法
## 12.1、堆

1. 定义：堆通常可以被看做是一棵完全二叉树的数组对象
> [完全二叉树](https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020)，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求节点都靠左


2. 特点

（1）它是完全二叉树
（2）它通常用数组来实现。具体方法就是将二叉树的结点按照层级顺序放入数组中
（3）堆中树的某个结点的父结点与左右子结点对应数组的索引关系：如果一个结点的位置为k，则它的父结点的位置为k/2,而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动
（4）每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的

3. 插入与删除的实现

插入：利用上浮算法进行数据插入，上浮算法就是将待上浮的结点与其父结点比较，如果待上浮的结点大于父结点，则交换位置，循环往复，直至待上浮的结点没有父结点。因此，将待插入的结点放到数组的最后一个元素，然后将插入的结点作为待上浮的结点，通过上浮算法将其放到合适的位置。
删除：下沉算法就是通过将待下沉的结点k，与其左子结点2k和右子结点2k+1中较大的结点进行比较，如果待下沉的结点小于左子结点和右子结点中较大的结点，则交换位置，循环往复，直至待下沉的结点没有左右子结点即叶子节点时完成下沉
# 
# 13、设计模式

1. 创建型模式：创建型模式关注对象的创建过程，主要包括简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式。
2. 结构型模式：结构型模式关注对象之间的组合和协作关系，主要包括适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式。
3. 行为型模式：行为型模式关注对象之间的交互和通信，主要包括模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式和访问者模式。
## 13.1、单例模式

1. 饿汉模式：在类加载时就完成了初始化，但是加载比较慢，获取对象比较快
```java
public class Singleton_hungry {
    //构造函数私有化
    private Singleton_hungry(){}
    //定义私有的引用
    private static Singleton_hungry instance = new Singleton_hungry();
    //对外提供获取实例的方法
    public static Singleton_hungry getInstance(){
        return instance;
    }
}
```

2. 懒汉模式：懒汉式是延时加载,他是在需要的时候才创建对象
```java
public class Singleton_lazy {
    //构造函数私有化
    private Singleton_lazy(){}
    private static Singleton_lazy instance;
    //对外提供获取实例的接口
    public static Singleton_lazy getInstance(){
        if (instance == null){
            instance =  new Singleton_lazy();
        }
        return instance;
    }
}

// 懒汉模式存在线程安全问题，用双重校验锁去解决
public class Singleton_lazy2 {
    private Singleton_lazy2(){};
    private static volatile Singleton_lazy2 instance;
    public Singleton_lazy2 getInstance(){
        //第一次校验singleton是否为空（已经创建实例不用竞争锁，提高效率）
        if(instance == null){
            synchronized (Singleton_lazy2.class){
                //第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断doubleLock是null，他就实例化了doubleLock，然后他出了锁，
                //这时候线程B经过等待A释放的锁，B获取锁了，如果没有第二个判断，那么他还是会去new DoubleLock()，再创建一个实例，所以为了防止这种情况，需要第二次判断
                if (instance == null){
                    instance =  new Singleton_lazy2();
                }
            }
        }
        return instance;
    }
}
```

## 13.2、简单工厂模式
简单工厂模式又称为**静态工厂方法**模式，它通过一个工厂类来创建不同类型的对象，客户端只需要知道具体产品的名称即可。
简单工厂模式的优点是简单易用，但是如果需要添加新的产品类型，则需要修改工厂类的代码，违反了开闭原则
```java
public class SimpleFactory {
    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new ConcreteProductA();
        } else if (type.equals("B")) {
            return new ConcreteProductB();
        } else {
            return null;
        }
    }
}
// 使用
Product product = SimpleFactory.createProduct("A");
```
## 13.3、工厂方法模式
工厂方法模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类只负责创建一种产品类型。客户端只需要知道具体工厂类的名称即可。
工厂方法模式的优点是更加灵活，可以更方便地添加新的产品类型，但是需要创建多个工厂类，增加了系统的复杂度。
```java
// 抽象工厂接口
public interface Factory {
    Product createProduct();
}
// 具体工厂类
public class ConcreteFactoryA implements Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

public class ConcreteFactoryB implements Factory {
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
// 使用
Factory factory = new ConcreteFactoryA();
Product product = factory.createProduct();
```
## 13.4、抽象工厂模式
抽象工厂模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类负责创建一组相关的产品类型。客户端需要知道具体的工厂类和产品族的名称。
抽象工厂模式的优点是可以创建一组相关的产品，而且更加灵活，但是需要创建多个工厂类和产品族，增加了系统的复杂度
```java
// 抽象工厂接口
public interface Factory {
    Product createProductA();
    Product createProductB();
}

// 具体工厂类
public class ConcreteFactory1 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA1();
    }

    public Product createProductB() {
        return new ConcreteProductB1();
    }
}

public class ConcreteFactory2 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA2();
    }

    public Product createProductB() {
        return new ConcreteProductB2();
    }
}

// 使用
Factory factory = new ConcreteFactory1();
Product productA = factory.createProductA();
Product productB = factory.createProductB();
```
## 13.5、原型模式
原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而不是通过实例化类来创建。这种模式适用于需要创建多个相似对象的情况，因为它可以减少对象创建的开销和复杂性
原型模式的优点包括：提高了对象创建的效率，减少了重复的代码，简化了对象创建的过程。缺点是如果原型对象的属性较为复杂或包含引用类型的属性，则需要进行深度克隆，否则会影响对象的正确性。
```java
public class Prototype implements Cloneable {
    private String name;
    private List<String> list;

    public Prototype(String name, List<String> list) {
        this.name = name;
        this.list = list;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<String> getList() {
        return list;
    }

    public void setList(List<String> list) {
        this.list = list;
    }

    @Override
    public Prototype clone() throws CloneNotSupportedException {
        Prototype prototype = (Prototype) super.clone();
        // 对包含的引用对象进行深度克隆
        prototype.list = new ArrayList<>(this.list);
        return prototype;
    }
}

```
## 13.6、装饰者模式
装饰者模式是一种结构型设计模式，它允许动态地向一个对象添加新的行为，同时又不影响其原有行为。这种模式的关键在于装饰者类和被装饰者类实现相同的接口，使得装饰者对象可以代替被装饰者对象，从而实现透明性。
在装饰者模式中，有四个角色：

1. 抽象组件（Component）
2. 具体组件（ConcreteComponent）
3. 抽象装饰者（Decorator）：实现抽象组件
4. 具体装饰者（ConcreteDecorator）：继承抽象装饰者

核心思想是：将对象的行为分离出来，使得每个行为都可以被单独地扩展和修改，而不会影响到其他行为。这种分离行为的方式是通过将行为封装到不同的类中，并将这些类组合起来形成一个**对象链**来实现
```java
// 抽象组件
interface Component {
    void operation();
}

// 具体组件
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("具体组件的操作");
    }
}

// 抽象装饰者
class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation();
    }
}

// 具体装饰者A
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者A的操作");
    }
}

// 具体装饰者B
class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者B的操作");
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        ConcreteComponent concreteComponent = new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);
        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);
        concreteDecoratorB.operation();
    }
}

```
## 13.7、代理模式
代理模式是一种结构型设计模式，主要作用是在访问对象时引入一定程度的间接性，以便更好地控制访问和管理对象。
Java中实现代理模式通常有两种方式：静态代理和动态代理
静态代理是指在编译时就已经确定代理类和被代理类的关系，代理类和被代理类都必须实现相同的接口或者继承相同的父类。静态代理的优点是简单易懂，缺点是需要为每一个被代理类写一个代理类，增加了代码量
```java
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// 代理类
class ProxySubject implements Subject {
    private RealSubject realSubject;

    public ProxySubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        System.out.println("ProxySubject.request()");
        realSubject.request();
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxySubject proxySubject = new ProxySubject(realSubject);
        proxySubject.request();
    }
}

```
动态代理是指在运行时动态生成代理类，不需要为每一个被代理类写一个代理类，可以节省代码量。Java中提供了两种动态代理机制：基于接口的动态代理和基于类的动态代理
```java
// 基于接口的动态代理：
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// InvocationHandler实现类
class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("ProxySubject.request()");
        Object result = method.invoke(target, args);
        return result;
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxyHandler proxyHandler = new ProxyHandler(realSubject);
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
                realSubject.getClass().getClassLoader(),
                realSubject.getClass().getInterfaces(),
                proxyHandler);
        proxySubject.request();
    }
}

```
## 13.7、享元模式
享元模式是一种结构型设计模式，它用于减少系统中对象的数量，从而提高系统的性能和效率。在享元模式中，多个对象共享相同的状态和数据，这些状态和数据通常是不可变的，因此可以被多个对象共享使用

1. 抽象享元（Flyweight）：定义享元对象的接口，通常包含一个操作方法。
2. 具体享元（ConcreteFlyweight）：实现抽象享元接口，包含内部状态和外部状态两部分，其中内部状态可以被共享，而外部状态需要在使用时传递给享元对象。
3. 享元工厂（FlyweightFactory）：用于创建和管理享元对象，通常使用工厂模式来实现。

在Java中，可以使用HashMap来存储享元对象，使用享元对象的属性作为HashMap的key，将享元对象作为HashMap的value。这样，当需要创建新的对象时，先在HashMap中查找是否已经存在相同属性的对象，如果存在，则返回已有的对象，否则创建新的对象并将其加入HashMap中
```java
import java.util.HashMap;

public class FlyweightFactory {
    private static final HashMap<String, Flyweight> flyweights = new HashMap<>();

    public static Flyweight getFlyweight(String key) {
        Flyweight flyweight = flyweights.get(key);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}

public interface Flyweight {
    void operation();
}

public class ConcreteFlyweight implements Flyweight {
    private String key;

    public ConcreteFlyweight(String key) {
        this.key = key;
    }

    public void operation() {
        System.out.println("ConcreteFlyweight with key " + key + " is performing operation.");
    }
}

public class Client {
    public static void main(String[] args) {
        Flyweight flyweight1 = FlyweightFactory.getFlyweight("key1");
        Flyweight flyweight2 = FlyweightFactory.getFlyweight("key2");
        Flyweight flyweight3 = FlyweightFactory.getFlyweight("key1");

        flyweight1.operation();
        flyweight2.operation();
        flyweight3.operation();

        System.out.println(flyweight1 == flyweight3); // true
    }
}

```

## 13.8、策略模式
策略模式是一种行为型设计模式，它允许选择算法的不同实现。在策略模式中，算法被封装在单独的类中，并且可以在运行时进行切换，以便在不同的情况下使用不同的算法
在策略模式中，有三个角色：策略接口、具体策略类和上下文类
上下文类包含一个策略接口的引用，并且可以在运行时切换具体策略类的实现
```java
// 策略接口
public interface SortStrategy {
    void sort(int[] data);
}
// 策略实现
public class BubbleSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 冒泡排序算法实现
    }
}

public class QuickSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 快速排序算法实现
    }
}

// 上下文类
public class Sorter {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] data) {
        strategy.sort(data);
    }
}

// 使用
int[] data = {4, 2, 1, 5, 3};
Sorter sorter = new Sorter();
sorter.setStrategy(new BubbleSortStrategy());
sorter.sort(data);

sorter.setStrategy(new QuickSortStrategy());
sorter.sort(data);
```

## 13.9、观察者模式
观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有依赖于它的观察者对象都会得到通知并自动更新
实现观察者模式需要定义两个接口：主题接口和观察者接口。主题接口定义了注册、删除和通知观察者的方法，观察者接口定义了更新自己状态的方法
最典型的应用场景就是消息订阅系统（如微博）
```java
// 被观察者类，即微博用户或话题
class Subject {
    private List<Observer> observers = new ArrayList<>(); // 观察者列表

    public void attach(Observer observer) { // 添加观察者
        observers.add(observer);
    }

    public void detach(Observer observer) { // 移除观察者
        observers.remove(observer);
    }

    public void notifyObservers(String message) { // 通知所有观察者
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 观察者接口，即微博用户
interface Observer {
    void update(String message);
}

// 具体观察者类，即关注了某个微博用户或话题的其他用户
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

// 测试代码
public class Test {
    public static void main(String[] args) {
        Subject subject = new Subject();

        ConcreteObserver user1 = new ConcreteObserver("User1");
        ConcreteObserver user2 = new ConcreteObserver("User2");
        ConcreteObserver topic1 = new ConcreteObserver("Topic1");

        subject.attach(user1);
        subject.attach(user2);
        subject.attach(topic1);

        subject.notifyObservers("Hello world!"); // 发布新消息

        subject.detach(user2); // 取消关注

        subject.notifyObservers("Goodbye!"); // 发布新消息
    }
}

```
# 14、Linux
## 14.1、防火墙常用命令
Firewalld和iptables都是Linux系统中常用的防火墙软件, Firewalld可以在运行时动态添加、删除和修改规则, 使用更加灵活
```shell
# 查看防火墙状态
systemctl status firewalld
# 查看所有开启的端口
firewall-cmd --list-ports
# 放行80端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
# 移除80端口
firewall-cmd --remove-port=80/tcp --permanent
# 重启防火墙
firewall-cmd --reload
```

## 14.2、进程号&端口号查看
```shell
# 查看java项目的进程
jsp
# 根据名称查看进程
ps -ef|grep ims
# 根据端口号查看进程(-alnp:所有连接  -tlnp:tcp连接)
netstat -alnp|grep 8090
# 根据进程号查看项目端口号
netstat -alnp|grep 119343
```
# 15、项目
### 15.1、云+2.0系统

