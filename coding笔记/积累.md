
## 6.4、redis如何实现分布式锁
在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境,而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁

1. 通过`set...nx...`命令,将加锁、过期命令编排到一起,把他们变成原子操作。完整命令：set key random-value nx ex seconds
> 其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令。
> 一般代指Redis中对set命令加上nx参数进行使用

> （1）nx  ex 是set指令的两个参数： ex过期时间    nx只有key不存在时设置新的key/value
> （2）key设置成随机数，避免一个线程过期时间内没释放掉锁，过期后有另一个线程获取到锁，该线程执行完后释放掉另一个线程获取的锁
> （3）设置过期时间（EX）作用：如果客户端忘记解锁,那么这种情况就很有可能造成死锁
> （4）NX的作用：避免重复获取锁


2. 解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。另外判断,释放这两步需要保持原子性，所以通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的
> if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end

> **这里为什么要用原子操作？**
> 主要是怕误将其他客户端的锁解开。比如客户端A加锁，一段时间之后客户端A解锁，在进入unlock后执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除

```java
import redis.clients.jedis.Jedis;

public class RedisLock {
    private Jedis jedis;

    public RedisLock(Jedis jedis) {
        this.jedis = jedis;
    }

    /**
     * 尝试获取锁
     * @param lockKey 锁的名称
     * @param requestId 请求标识，用于释放锁
     * @param expireTime 锁的过期时间
     * @return 是否成功获取锁
     */
    public boolean tryLock(String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, "NX", "EX", expireTime);
        if ("OK".equals(result)) {
            return true;
        }
        return false;
    }

    /**
     * 释放锁
     * @param lockKey 锁的名称
     * @param requestId 请求标识，用于判断是否是同一个客户端
     * @return 是否成功释放锁
     */
    public boolean releaseLock(String lockKey, String requestId) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        // jedis.eval是Jedis客户端提供的一个用于执行Lua脚本的方法
        Long result = (Long) jedis.eval(script, 1, lockKey, requestId);
        if (result == 1) {
            return true;
        }
        return false;
    }
}

```
> 另外可以通过Redisson框架，它的底层原理其实也是这个setnx


## 6.5、redis与数据库如何保持双写一致性？
更新数据库和更新redis不是一个原子操作。所以根据业务场景有两种方案：

1. 保证最终一致性（可以接受数据短期不一致）

先更新数据库，再更新redis。第二步更新redis失败的请求异步写入mq消息队列，利用mq的重试机制进行更新
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679227622125-f3d54dc1-93ef-4b79-936a-d452094a32ad.png#averageHue=%23eef9fa&clientId=u6b9b4d54-8d47-4&from=paste&height=396&id=u8e4b224b&originHeight=509&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134774&status=done&style=none&taskId=u81e57ee2-caba-4777-837e-637f12e6355&title=&width=596)

2. 强一致性保证

使用读写锁，在数据更新的时候，其它任何请求都无法访问缓存中的数据
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679227590591-d848dbe5-4ef0-4c08-8239-cd6043ad91bc.png#averageHue=%23f0fafa&clientId=u6b9b4d54-8d47-4&from=paste&height=297&id=uad8553b6&originHeight=297&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76361&status=done&style=none&taskId=uc58241c3-765d-40d2-b2b8-600c1b4dc0c&title=&width=610)
## 6.6、redis是单线程的吗
Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行
> redis为什么快？（1）单线程避免了线程竞争和切换带来的开销（2）基于内存，所以读写都比较快 （3）采用多路复用非阻塞I/O


## 6.7、如何实现redis高可用

1. **主从复制**：写一定是在主服务器上，然后主服务器同步给从服务器。

缺点：当主服务器挂掉的时候，不能自动切换到从服务器上。主从服务器存储数据一样，内存可用性差。
优点：在一定程度上分担主服务器读的压力。

2. **哨兵模式**：构建多个哨兵节点监视主从服务器，当主服务器挂掉的时候，自动将对应的从服务器切换成主服务器。

优点：实现自动切换，可用性高。
缺点：主从服务器存储数据一致，内存可用性差。还要额外维护一套哨兵系统，较为麻烦。

3. **集群模式**：采用无中心节点的方式实现。多个主服务器相连，一个主服务器可以有多个从服务器，不同的主服务器存储不同的数据。

优点：可用性更高，内存可用性高。

## 6.8、说说缓存穿透、击穿、雪崩的区别
缓存击穿：一份热点数据，在它缓存失效期间，大量的请求直接命中存储层。 
> 解决方法：
> 1.设置热点数据永不过期的策略。
> 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了。

缓存穿透：某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机。 
> 解决方法：
> 1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。
> 2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值。 

> 布隆过滤器：它是一种类似哈希的数据结构，通过这个数据结构，可以快速的插入和查询，确定某个事件一定不存在或可能存在。特点是占用空间少，缺点是返回的结果是概率性
> 当一个元素加入集合时，就通过K个hash函数将这个映射成一个位数组中的K个点，把它们置为1。当查询时，只要检查这些点是否全为1，就能判断集合中是否可能存在。
> 如果k个点有任何一个0，则被检元素一定不在。如果都是1，则很可能存在，这个期望概率是可以设置

缓存雪崩：由于某些原因，中间层的缓存层不能提供服务，大量的请求直达数据存储层，导致宕机。 
> 解决方法：
> 1.设置多级缓存，在存储层之前加上一层本地缓存。
> 2.构建高可用的redis缓存，部署多个redis实例，个别不能用，也不至于宕机。


## 6.9、redis内存淘汰策略
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据
> LRU：淘汰最长时间没有被使用的
> LFU：一定时间内使用频次越低的
> random：随机
> ttl：越早过期的数据

| **淘汰策略名称** | **策略含义** |
| --- | --- |
| noeviction | 默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外） |
| allkeys-lru | 从所有数据中根据 LRU 算法挑选数据淘汰 |
| volatile-lru | 从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰 |
| allkeys-random | 从所有数据中随机挑选数据淘汰 |
| volatile-random | 从设置了过期时间的数据中随机挑选数据淘汰 |
| volatile-ttl | 从设置了过期时间的数据中，挑选越早过期的数据进行删除 |
| allkeys-lfu | 从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用） |
| volatile-lfu | 从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用） |



# 7、mq
## 7.1、mq的用处和缺点
**优势：**
（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单
（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度
（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。
**劣势：**
（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用
（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？
（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性

## 7.2、rabbitmq组件

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675740684760-d44e0791-b1da-483d-9274-a2e68714e7c7.png#averageHue=%23d3d35b&clientId=u1c130bb5-33d5-4&from=paste&height=268&id=u515cf7a8&originHeight=268&originWidth=893&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60804&status=done&style=none&taskId=ucf018e58-a4ed-4020-9313-abf54159de2&title=&width=893)

（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。
（2）Connection：连接，应用程序与Server的网络连接，TCP连接。
（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
> 如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接
> Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销

（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。
（6）Queue：消息队列，用来保存消息，供消费者消费
（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。
（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”

## 7.3、rabbitMQ交换机类型

1. Direct Exchange（直连交换机）

根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661233986129-afce563d-98b7-4559-bc81-bffb856d29ef.png#averageHue=%23f7e1e1&clientId=u1f2092d6-850c-4&from=paste&height=144&id=u22753071&originHeight=144&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15620&status=done&style=none&taskId=uac52e483-773c-4871-81de-6ee3aac512d&title=&width=379)

2. Fanout Exchange

该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么
> 如果想让多个消费者消费到数据必须不指定queues，指定交换机

```java
@RabbitListener(bindings = @QueueBinding(

        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生

        exchange = @Exchange(value = "business_rrpc_exchange",type = ExchangeTypes.FANOUT)

))

```

3.  Topic Exchange（主题交换机）
将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.*  ” 只会匹配到“abc.def”。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661234502774-bcf2c312-eb4a-4b08-bdf4-04d1e00120c6.png#averageHue=%23f7e2e2&clientId=u1f2092d6-850c-4&from=paste&height=145&id=ufa6d9153&originHeight=145&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16576&status=done&style=none&taskId=udb8c02a0-8915-45bc-94a0-57fc472954b&title=&width=397)

4. Headers Exchanges（头交换机）

与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列
> 匹配规则x-match有下列两种类型：
x-match = all ：表示所有的键值对都匹配才能接受到消息
x-match = any ：表示只要有键值对匹配就能接受到消息

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661235159094-3892f748-0b85-4434-ae94-8312b03666ee.png#averageHue=%23fcf3f2&clientId=u1f2092d6-850c-4&from=paste&id=ud65c1929&originHeight=225&originWidth=587&originalType=url&ratio=1&rotation=0&showTitle=false&size=25703&status=done&style=none&taskId=uc66d4e00-7f87-4157-b04d-eaf97a4ed47&title=)

## 7.4、rabbitMQ工作模式
> 简单模式和工作队列模式都是点对点模式。其他的都是发布与订阅模式

1. 简单模式

一个生产者对应一个消费者。这个模式下一个发生一个接收，不用考虑交换机。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675751154663-d967a570-e70e-472e-9d91-b702900a369b.png#averageHue=%23f9dede&clientId=u1c130bb5-33d5-4&from=paste&height=123&id=uab8c94c4&originHeight=123&originWidth=357&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8784&status=done&style=none&taskId=u600ec559-c0f1-42a0-a353-2a4db284d6f&title=&width=357)
> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理

```java
@Component
public class MessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void send(String message) {
        rabbitTemplate.convertAndSend("simple.queue", message);
    }
}

@Component
public class MessageReceiver {
 
    @RabbitListener(queues = "simple.queue")
    public void receive(String message) {
        System.out.println("Received message: " + message);
    }
}

```

2. 工作队列模式

一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息。谁先拿到谁消费
> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度


![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1675751171601-c5a2995a-018e-4f3e-9165-9af05c8ffaae.png#averageHue=%23f8dada&clientId=u1c130bb5-33d5-4&from=paste&height=146&id=u0cbbec5c&originHeight=146&originWidth=382&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14008&status=done&style=none&taskId=u4a973303-a770-4b77-92bc-a9f98b94856&title=&width=382)

3. 发布订阅模式

生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息
![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661236597993-e6418afb-21a5-4198-a6d8-1ac88d7f6e68.png#averageHue=%23f7dada&from=url&id=GMqUi&originHeight=164&originWidth=391&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
```java
// 生产者
@Component
public class MessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void send(String message) {
        rabbitTemplate.convertAndSend("fanout-exchange", "", message);
    }
}
// 消费者
@Component
public class MessageConsumer {

    @RabbitListener(queues = "queue-1")
    public void receiveFromQueue1(String message) {
        System.out.println("Received message from queue-1: " + message);
    }

    @RabbitListener(queues = "queue-2")
    public void receiveFromQueue2(String message) {
        System.out.println("Received message from queue-2: " + message);
    }
}

// 交换机绑定队列
@Configuration
public class RabbitMQConfig {

    @Bean
    public FanoutExchange fanoutExchange() {
        return new FanoutExchange("fanout-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, FanoutExchange fanoutExchange) {
        return BindingBuilder.bind(queue1).to(fanoutExchange);
    }

    @Bean
    public Binding binding2(Queue queue2, FanoutExchange fanoutExchange) {
        return BindingBuilder.bind(queue2).to(fanoutExchange);
    }
}



```

4. 路由模式

生产者发送的消息是以key-value的形式，当消息进入交换机，交换机根据key的不同，将其分配到不同的队列。消费者通过Channel声明一个队列时，需要绑定给队列绑定一个key和一个交换机。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661238576118-08d05cd0-ec41-4db8-922a-4eea1ae99e16.png#averageHue=%23f6e4e4&clientId=u1f2092d6-850c-4&from=paste&height=148&id=u15bd2eac&originHeight=148&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22813&status=done&style=none&taskId=uee97833f-f94d-46df-9cdb-0cb79ad29ea&title=&width=396)
```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public DirectExchange directExchange() {
        return new DirectExchange("direct-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, DirectExchange directExchange) {
        return BindingBuilder.bind(queue1).to(directExchange).with("routing-key-1");
    }

    @Bean
    public Binding binding2(Queue queue2, DirectExchange directExchange) {
        return BindingBuilder.bind(queue2).to(directExchange).with("routing-key-2");
    }
}

```



5. 主题模式

主题模式从某种意义上也算是一种路由，只不过它可以匹配多种符合条件的队列。Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符
> *可以代替一个单词，#代表没有和多个单词

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661239369166-9fb94bca-0467-4982-8b2e-4528148a35a6.png#averageHue=%23f6e5e1&clientId=u1f2092d6-850c-4&from=paste&height=185&id=udc9a98eb&originHeight=185&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65300&status=done&style=none&taskId=u289c5cfc-f051-4301-ae36-55835a1b2c3&title=&width=561)
```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public TopicExchange topicExchange() {
        return new TopicExchange("topic-exchange");
    }

    @Bean
    public Queue queue1() {
        return new Queue("queue-1");
    }

    @Bean
    public Queue queue2() {
        return new Queue("queue-2");
    }

    @Bean
    public Binding binding1(Queue queue1, TopicExchange topicExchange) {
        return BindingBuilder.bind(queue1).to(topicExchange).with("topic.key.*");
    }

    @Bean
    public Binding binding2(Queue queue2, TopicExchange topicExchange) {
        return BindingBuilder.bind(queue2).to(topicExchange).with("topic.#");
    }
}

```

## 7.5、如何保证消息不丢失？

1. **生产者->broker**

confirmCallback 确认模式。(无论成功失败都有返回)
（1）在配置文件中开启消息确认模式
（2）通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理

2. **broker中**

消息回退：消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）
> rabbitTemplate.setMandatory(true)

持久化：保证重启过程中，交换机和队列也是持久化的

3. **broker ->消费者**

消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除

（1）rabbitmq默认的是自动ack，无需添加其他配置
若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。
若消费过程中出现异常，则超过ack心跳时间，会触发重试消费

（2）手动ack
开启方式简单，只需要放开此配置即可
> acknowledge-mode: manual #设置消费端手动 ack

## 7.6、如何保证消息的顺序性
出现无序的场景：一个队列有多个消费者消费的时候，这些消息被多个线程并发消费，并发是不能保证顺序的

1. mq层面：拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)
2. 应用层层面：消息实体中增加：版本号 & msgid & parent_msgid，通过 parent_msgid 判断消息的顺序（需要全局存储，记录消息的执行状态）
## 7.7、死信队列
死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？

“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：
（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue 属性被设置为false。
（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。
（3）消息队列的消息数量已经超过最大队列长度。
  那么该消息将成为“死信”。
“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。

## 7.8、如何实现延迟队列（DLX 实现）
实现思路： 我们可以把死信队列就当成延迟队列
假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 routing_key，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。

## 7.9、emqx & MQTT	
mqtt  和 emqx 的关系类比于amqp和 rabbitmq，是协议和实现的关系
mqtt开销很小，协议交换最小化，以降低网络流量。所以非常在物联网领域（嵌入式设备的运算能力和带宽都相对薄弱）

## 7.10、如何保证消息不被重复消费（幂等性）
> 场景：消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，重新发送，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；


> 所谓幂等性，就是数据无论操作多少次，所产生的影响跟执行一次是一样的，比如对于读操作来说，无论读取多少次数据，都跟读取一次的数据是一样的，所以读操作是一个幂等性操作，而添加操作，添加多次会有多条记录，因而写操作则是非幂等性操作

可以通过给消息的某一些属性设置唯一约束，比如增加唯一uuid，添加的时候查询是否存对应的uuid，存在不操作，不存在则添加，那样对于相同的uuid只会存在一条数据。（注：但需要保证查询跟添加的操作必须是原子性操作，可以使用setnx保证原子）
```java
 boolean send = jedisClient.setnx(channel, uuid) == 1;
if(send){
     // TODO 开始发送短信
}
```

## 7.11、MQTT
MQTT是一种轻量级的、基于发布/订阅模式的消息传输协议，主要用于物联网.MQTT协议的设计非常简单,所以带宽的开销很小，很适合小型的嵌入式设备。MQTT显示上没有rabbitmq中交换机，队列的概念，生产者将消息发布到一个主题（Topic）中，而消费者则订阅该主题，以便接收相应的消息，从而实现消息的传递和交互
# 8、网络
## 8.1、长连接和短连接的区别？
HTTP的长连接和短连接本质上是TCP长连接和短连接
**长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。直到服务器超时自动断开链接，或者客户端主动断开链接
**短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。
> 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。
> Http长连接 和 TCP长连接的区别在于: TCP 的长连接需要自己去维护一套心跳策略。，而Http只需要在请求头加入keep-alive:true即可实现长连接


## 8.2、cookie和session的区别？

1. 存储位置：cookie存储在客户端浏览器中，session存储在服务器端。
2. 安全性：cookie可以被客户端修改和窃取，因此不适合存储敏感信息。而session存储在服务器端，只有服务器可以访问它，因此更加安全。
3. 存储容量：cookie的存储容量有限，通常只能存储少量的数据。而session可以存储大量的数据，因为它存储在服务器端。（具体容量看设置，cookie默认4kb，session几十兆）
4. 过期时间：cookie可以设置过期时间，当过期时，浏览器会自动删除cookie。而session在用户关闭浏览器时会自动过期。

总的来说，cookie适合用于存储少量的非敏感信息，如用户偏好设置、购物车信息等；而session适合用于存储大量的敏感信息，如用户登录状态、权限等
# 9、dubbo
## 9.1、dubbo和springCloud区别
两者都是现在主流的分布式框架，但却存在不少差异：

- **生态环境不同：** SpringCloud定位为微服务架构下的一站式解决方案（网关，分布式配置，服务跟踪）；Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用和治理
- **调用方式：** SpringCloud是采用Http协议做远程调用；Dubbo是基于RPC调用
- **组件差异比较多**，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper

![](https://cdn.nlark.com/yuque/0/2023/webp/2996398/1675996970042-0552f61a-26e1-402c-9dc1-642431c222ab.webp#averageHue=%23eff3f2&clientId=ued21274a-04e3-4&from=paste&id=ue20f9ce5&originHeight=341&originWidth=771&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u280d4e8b-f356-4658-9572-330db8e00f5&title=)

## 9.2、dubbo支持哪些协议
**1、dubbo 默认协议：**

- 单一 TCP 长连接，Hessian 二进制序列化和 NIO 异步通讯
- 不适合传送大数据包的服务

**2、rmi 协议：**

- 采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式
- 对传输数据包不限，消费者和传输者个数相当

**3、hessian 协议：**

- 底层 Http 通讯，Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现
- 通讯效率高于 WebService 和 Java 自带的序列化
- 适用于传输数据包较大，提供者比消费者个数多，提供者压力较大

**4、http 协议：**

- 基于 http 表单的远程调用协议，短连接，json 序列化
- 对传输数据包不限，不支持传文件

**5、webservice 协议：**

- 基于 Apache CXF 的 frontend-simple 和 transports-http 实现，短连接，SOAP文本序列化
- 可与原生 WebService 服务互操作
- 适用于系统集成、跨语言调用

**6、thrift 协议：**

- 对 thrift 原生协议 [2] 的扩展添加了额外的头信息
- 使用较少，不支持传 null 值

**7、基于 Redis实现的 RPC 协议**
**8、基于 Memcached 实现的 RPC 协议】**

## 9.3、dubbo负载均衡策略
```java
dubbo:
  provider:
    loadbalance: roundrobin
```
> 也可以在注解上进行配置
> @Service(version = "${product.service.version}",loadbalance="roundrobin")

1. RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的**默认**负载均衡策略。
2. RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。
3. LeastActiveLoadBalance: 最小活跃数负载均衡，活跃数也就是dubbo的连接数，每当收到一个请求活跃数+1，结束请求活跃数-1，假设如果多台机器的连接数是相同的，如果一台机器性能比较好，处理请求比较快那么活跃数减少的就快，活跃数就少。所以活跃数少的就会获取到的请求会变多，这样就可以合理的使用性能不同的机器了
4. ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。

## 9.4、dubbo集群容错
| **类型** | **负载均衡** | **备注** |
| --- | --- | --- |
| failover | 会 | 失败后会尝试调用其他服务器实例，默认尝试2次， 可以通过设置retries来设置次数。这是dubbo默认的容错机制，由于常常可能因为超时待原因触发异常但远程服务已经完成操作，所以这个类型不应就在数据更新的操作 |
| failfast | 会 | 有异常立即返回，不做尝试，我认为可以用在数据更新上，以保证数据的一致性 |
| fastsafe | 会 | 有异常会直接忽略，为的是保证调用方接下来的正常运行，一般用于日志收集等与正常流程无关的操作 |
| failback | 会 | 失败后会将任务丢到失败队列中，并会异步再次尝试 |
| forking | 否 | 同时调用多个服务，取最先返回的结果，可以通过forks设置最大并行数，这比较浪费资源 |
| broadcast | 否 | 调用所有可用的服务，任意一个有错都会返回异常 |
| Mock | 否 | 调用失败时返回伪造的响应结果 |

> 一般在@DubboService或@DubboReference指定cluster即可，如
@DubboService(cluster = “failover”) //默认重试2次


## 9.5、dubbo节点角色

1. Container：服务运行容器。
2. Provider：暴露服务的服务提供方。
3. Consumer：调用远程服务的服务消费方。
4. Registry：服务注册与发现的注册中心。
5. Monitor：统计服务的调用次数和调用时间的监控中心。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1676255772897-ef7e967d-0649-47fc-9619-df682d81623d.png#averageHue=%23fdfdfd&clientId=u8e7e2608-ecdb-4&from=paste&height=436&id=ued12782e&originHeight=824&originWidth=1060&originalType=url&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=u97be041b-5627-4a7c-bd1d-83152ce3e7b&title=&width=561)
## 9.5、dubbo调用过程

1. 服务容器 Container 负责启动加载运行服务提供者 Provider。根据配置中的 Registry 地址连接 Registry，在 Registry 注册自己提供的服务。
2. Consumer 在启动时，根据配置文件中的服务引用信息，连接到 Registry，向 Registry 订阅自己所需的服务。
4. Registry 根据服务订阅关系，返回 Provider 地址列表给 Consumer。如果有变更，Registry 会基于长连接推送最新的服务地址信息给 Consumer。
5. Consumer 调用远程服务时，基于负载均衡算法，从缓存的 Provider 地址列表中选择一台进行跨进程调用服务
6. 服务 Provider 和 Consumer，会在内存中记录调用次数和调用时间，每分钟发送一次统计数据到 Monitor。

# 10、springCloud
## 10.1、如何保证分布式事务一致性？

1. 首先是设计方案尽可能规避分布式事务的场景（相似的业务放在一起，不要过度的拆分）
2. 根据业务场景，选择使用柔性事务（ap）还是强事务(cp)

如果可以允许消息存在一段时间不一致，只要保证最终一致性，可以用本地消息表来做。如果要保证一致性，可以用2pc，具体实现方案有阿里的seata

3. 本地消息表（柔性事务）

不去同步的调用，先将要请求的消息插入到本地的消息表中，消息状态为正在处理，起一个定时任务去查询消息表，将正在处理的消息发送到消息队列，B中消息处理完后，向一个return队列发送一个成功的消息，A订阅了该消息队列，收到成功的消息后将状态该为处理完毕。（被调用方应保证幂等性，如库存系统在减库存前先查流水表，看该订单是否扣过库存，扣过就不执行）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679844537244-b3de5d9e-7e6e-4b74-9345-cbb66fedcb80.png#averageHue=%23f5f5f5&clientId=u051b1bd0-acdc-4&from=paste&height=454&id=u41a8bcd9&originHeight=454&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131665&status=done&style=none&taskId=u5de36835-b151-439d-8526-90f53f7550e&title=&width=1389)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2996398/1679845311357-39625a82-0e3e-4795-bd7e-5643f203abe8.png#averageHue=%23f0f0f0&clientId=u051b1bd0-acdc-4&from=paste&height=204&id=uf58d5a6a&originHeight=204&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38032&status=done&style=none&taskId=u4db46ad2-afb8-4c97-abaf-64c4c34f5eb&title=&width=642)

## 10.2、架构的演进
单体-垂直-分布式-SOA-微服务 （详情看springcloud笔记开头部分）

## 10.3、分布式和微服务有什么关系？
我理解的分布式是一种系统架构，指一个系统由多个独立的组件组成，这些组件可以在不同的物理位置上运行，从而提升了系统的性能
而微服务可以看作是分布式的一种实现方案。分布式实现方案有soa，基于rpc远程调用（dubbo），微服务（springcloud）

# 11、场景题
## 11.1、两个50亿url的文件如何找出共同的url
**问题：**给A，B两个文件，各存放50亿条URL，每条URL占用64个字节，内存限制为4G，找出A，B中相同的URL。

**分析：**可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法

**方案：**分治思想

1. 分治思想遍历文件A，对每个url求hash(url)%N，然后将取得的值分布到N个小文件中，每个小文件可以放在内存中。
2. 遍历文件B，采取和A相同的方式将url存储到N个小文件中.
3. 分布取两个小文件，把一个小文件加入hashset，然后遍历另一个，如果url在哈希表，则为共同url，汇总到结果中。
> 有可能出现哈希碰撞，可以采用多个哈希函数减少碰撞概率。


## 11.2、如何从1000w记录中，找出最热门的10个记录？
> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前一个日志文件中有一千万个记录 (这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过了百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门) ，请你统计最热门的1口个查询串，要求使用的内存不能超过1G


> 1000万条记录，每条记录最大为255Byte，那么日志文件最大有2.5G左右（超过1G）
> 如果去重复有100万条记录，占用250M内存。那么我们可以考虑将这些无重复的记录装入内存
> 这时我们需要一种数据结构，这种数据结构即能够存储查询串，又能存储查询串的出现次数。

    第一步、先对这批海量数据预处理，用hashmap存储，key为内容，value为出现次数 。O（N）
    第二步、创建一个长度为10的小根堆，遍历hashmap，如果MinHeap未满，那么往MinHeap中插入这个键值对，如果MinHeap满了，则比较遍历到的元素的count值堆顶的count，如果遍历到元素的count大于堆顶count值，删除堆顶元素，插入当前遍历到的元素。遍历完整个hashmap以后，在MinHeap中存储的就是最热门10个查询串

## 11.3、20亿个用户统计登录状态
> 20亿的用户，频繁改变数据库，io极大，数据库性能可能会被拖垮。
> 考虑使用redis，如果用set存储，登录存入set，退出删除。一个用户按4字节，10亿个用户4G内存，太大

我们使用redis的bitmap来进行存储。
setbit命今 语法:setbit key offset value  设置或修改key上的偏移量 (offset) 的位 (value) 的值
10亿用户，1个用户只占用1bit 相比于set占用的4字节，优化了了32倍那么节省后的内存为125MB。
优点:查找效率高。
缺点: 结果数据不能重复，数据如果太过分散会造成浪费，只有数据密集才可以

# 12、数据结构和算法
## 12.1、堆

1. 定义：堆通常可以被看做是一棵完全二叉树的数组对象
> [完全二叉树](https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020)，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求节点都靠左


2. 特点

（1）它是完全二叉树
（2）它通常用数组来实现。具体方法就是将二叉树的结点按照层级顺序放入数组中
（3）堆中树的某个结点的父结点与左右子结点对应数组的索引关系：如果一个结点的位置为k，则它的父结点的位置为k/2,而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动
（4）每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的

3. 插入与删除的实现

插入：利用上浮算法进行数据插入，上浮算法就是将待上浮的结点与其父结点比较，如果待上浮的结点大于父结点，则交换位置，循环往复，直至待上浮的结点没有父结点。因此，将待插入的结点放到数组的最后一个元素，然后将插入的结点作为待上浮的结点，通过上浮算法将其放到合适的位置。
删除：下沉算法就是通过将待下沉的结点k，与其左子结点2k和右子结点2k+1中较大的结点进行比较，如果待下沉的结点小于左子结点和右子结点中较大的结点，则交换位置，循环往复，直至待下沉的结点没有左右子结点即叶子节点时完成下沉
# 
# 13、设计模式

1. 创建型模式：创建型模式关注对象的创建过程，主要包括简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式。
2. 结构型模式：结构型模式关注对象之间的组合和协作关系，主要包括适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式。
3. 行为型模式：行为型模式关注对象之间的交互和通信，主要包括模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式和访问者模式。
## 13.1、单例模式

1. 饿汉模式：在类加载时就完成了初始化，但是加载比较慢，获取对象比较快
```java
public class Singleton_hungry {
    //构造函数私有化
    private Singleton_hungry(){}
    //定义私有的引用
    private static Singleton_hungry instance = new Singleton_hungry();
    //对外提供获取实例的方法
    public static Singleton_hungry getInstance(){
        return instance;
    }
}
```

2. 懒汉模式：懒汉式是延时加载,他是在需要的时候才创建对象
```java
public class Singleton_lazy {
    //构造函数私有化
    private Singleton_lazy(){}
    private static Singleton_lazy instance;
    //对外提供获取实例的接口
    public static Singleton_lazy getInstance(){
        if (instance == null){
            instance =  new Singleton_lazy();
        }
        return instance;
    }
}

// 懒汉模式存在线程安全问题，用双重校验锁去解决
public class Singleton_lazy2 {
    private Singleton_lazy2(){};
    private static volatile Singleton_lazy2 instance;
    public Singleton_lazy2 getInstance(){
        //第一次校验singleton是否为空（已经创建实例不用竞争锁，提高效率）
        if(instance == null){
            synchronized (Singleton_lazy2.class){
                //第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断doubleLock是null，他就实例化了doubleLock，然后他出了锁，
                //这时候线程B经过等待A释放的锁，B获取锁了，如果没有第二个判断，那么他还是会去new DoubleLock()，再创建一个实例，所以为了防止这种情况，需要第二次判断
                if (instance == null){
                    instance =  new Singleton_lazy2();
                }
            }
        }
        return instance;
    }
}
```

## 13.2、简单工厂模式
简单工厂模式又称为**静态工厂方法**模式，它通过一个工厂类来创建不同类型的对象，客户端只需要知道具体产品的名称即可。
简单工厂模式的优点是简单易用，但是如果需要添加新的产品类型，则需要修改工厂类的代码，违反了开闭原则
```java
public class SimpleFactory {
    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new ConcreteProductA();
        } else if (type.equals("B")) {
            return new ConcreteProductB();
        } else {
            return null;
        }
    }
}
// 使用
Product product = SimpleFactory.createProduct("A");
```
## 13.3、工厂方法模式
工厂方法模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类只负责创建一种产品类型。客户端只需要知道具体工厂类的名称即可。
工厂方法模式的优点是更加灵活，可以更方便地添加新的产品类型，但是需要创建多个工厂类，增加了系统的复杂度。
```java
// 抽象工厂接口
public interface Factory {
    Product createProduct();
}
// 具体工厂类
public class ConcreteFactoryA implements Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

public class ConcreteFactoryB implements Factory {
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
// 使用
Factory factory = new ConcreteFactoryA();
Product product = factory.createProduct();
```
## 13.4、抽象工厂模式
抽象工厂模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类负责创建一组相关的产品类型。客户端需要知道具体的工厂类和产品族的名称。
抽象工厂模式的优点是可以创建一组相关的产品，而且更加灵活，但是需要创建多个工厂类和产品族，增加了系统的复杂度
```java
// 抽象工厂接口
public interface Factory {
    Product createProductA();
    Product createProductB();
}

// 具体工厂类
public class ConcreteFactory1 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA1();
    }

    public Product createProductB() {
        return new ConcreteProductB1();
    }
}

public class ConcreteFactory2 implements Factory {
    public Product createProductA() {
        return new ConcreteProductA2();
    }

    public Product createProductB() {
        return new ConcreteProductB2();
    }
}

// 使用
Factory factory = new ConcreteFactory1();
Product productA = factory.createProductA();
Product productB = factory.createProductB();
```
## 13.5、原型模式
原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而不是通过实例化类来创建。这种模式适用于需要创建多个相似对象的情况，因为它可以减少对象创建的开销和复杂性
原型模式的优点包括：提高了对象创建的效率，减少了重复的代码，简化了对象创建的过程。缺点是如果原型对象的属性较为复杂或包含引用类型的属性，则需要进行深度克隆，否则会影响对象的正确性。
```java
public class Prototype implements Cloneable {
    private String name;
    private List<String> list;

    public Prototype(String name, List<String> list) {
        this.name = name;
        this.list = list;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<String> getList() {
        return list;
    }

    public void setList(List<String> list) {
        this.list = list;
    }

    @Override
    public Prototype clone() throws CloneNotSupportedException {
        Prototype prototype = (Prototype) super.clone();
        // 对包含的引用对象进行深度克隆
        prototype.list = new ArrayList<>(this.list);
        return prototype;
    }
}

```
## 13.6、装饰者模式
装饰者模式是一种结构型设计模式，它允许动态地向一个对象添加新的行为，同时又不影响其原有行为。这种模式的关键在于装饰者类和被装饰者类实现相同的接口，使得装饰者对象可以代替被装饰者对象，从而实现透明性。
在装饰者模式中，有四个角色：

1. 抽象组件（Component）
2. 具体组件（ConcreteComponent）
3. 抽象装饰者（Decorator）：实现抽象组件
4. 具体装饰者（ConcreteDecorator）：继承抽象装饰者

核心思想是：将对象的行为分离出来，使得每个行为都可以被单独地扩展和修改，而不会影响到其他行为。这种分离行为的方式是通过将行为封装到不同的类中，并将这些类组合起来形成一个**对象链**来实现
```java
// 抽象组件
interface Component {
    void operation();
}

// 具体组件
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("具体组件的操作");
    }
}

// 抽象装饰者
class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation();
    }
}

// 具体装饰者A
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者A的操作");
    }
}

// 具体装饰者B
class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("具体装饰者B的操作");
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        ConcreteComponent concreteComponent = new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);
        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);
        concreteDecoratorB.operation();
    }
}

```
## 13.7、代理模式
代理模式是一种结构型设计模式，主要作用是在访问对象时引入一定程度的间接性，以便更好地控制访问和管理对象。
Java中实现代理模式通常有两种方式：静态代理和动态代理
静态代理是指在编译时就已经确定代理类和被代理类的关系，代理类和被代理类都必须实现相同的接口或者继承相同的父类。静态代理的优点是简单易懂，缺点是需要为每一个被代理类写一个代理类，增加了代码量
```java
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// 代理类
class ProxySubject implements Subject {
    private RealSubject realSubject;

    public ProxySubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        System.out.println("ProxySubject.request()");
        realSubject.request();
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxySubject proxySubject = new ProxySubject(realSubject);
        proxySubject.request();
    }
}

```
动态代理是指在运行时动态生成代理类，不需要为每一个被代理类写一个代理类，可以节省代码量。Java中提供了两种动态代理机制：基于接口的动态代理和基于类的动态代理
```java
// 基于接口的动态代理：
// 抽象主题接口
interface Subject {
    void request();
}

// 实际主题类
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject.request()");
    }
}

// InvocationHandler实现类
class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("ProxySubject.request()");
        Object result = method.invoke(target, args);
        return result;
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        ProxyHandler proxyHandler = new ProxyHandler(realSubject);
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
                realSubject.getClass().getClassLoader(),
                realSubject.getClass().getInterfaces(),
                proxyHandler);
        proxySubject.request();
    }
}

```
## 13.7、享元模式
享元模式是一种结构型设计模式，它用于减少系统中对象的数量，从而提高系统的性能和效率。在享元模式中，多个对象共享相同的状态和数据，这些状态和数据通常是不可变的，因此可以被多个对象共享使用

1. 抽象享元（Flyweight）：定义享元对象的接口，通常包含一个操作方法。
2. 具体享元（ConcreteFlyweight）：实现抽象享元接口，包含内部状态和外部状态两部分，其中内部状态可以被共享，而外部状态需要在使用时传递给享元对象。
3. 享元工厂（FlyweightFactory）：用于创建和管理享元对象，通常使用工厂模式来实现。

在Java中，可以使用HashMap来存储享元对象，使用享元对象的属性作为HashMap的key，将享元对象作为HashMap的value。这样，当需要创建新的对象时，先在HashMap中查找是否已经存在相同属性的对象，如果存在，则返回已有的对象，否则创建新的对象并将其加入HashMap中
```java
import java.util.HashMap;

public class FlyweightFactory {
    private static final HashMap<String, Flyweight> flyweights = new HashMap<>();

    public static Flyweight getFlyweight(String key) {
        Flyweight flyweight = flyweights.get(key);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}

public interface Flyweight {
    void operation();
}

public class ConcreteFlyweight implements Flyweight {
    private String key;

    public ConcreteFlyweight(String key) {
        this.key = key;
    }

    public void operation() {
        System.out.println("ConcreteFlyweight with key " + key + " is performing operation.");
    }
}

public class Client {
    public static void main(String[] args) {
        Flyweight flyweight1 = FlyweightFactory.getFlyweight("key1");
        Flyweight flyweight2 = FlyweightFactory.getFlyweight("key2");
        Flyweight flyweight3 = FlyweightFactory.getFlyweight("key1");

        flyweight1.operation();
        flyweight2.operation();
        flyweight3.operation();

        System.out.println(flyweight1 == flyweight3); // true
    }
}

```

## 13.8、策略模式
策略模式是一种行为型设计模式，它允许选择算法的不同实现。在策略模式中，算法被封装在单独的类中，并且可以在运行时进行切换，以便在不同的情况下使用不同的算法
在策略模式中，有三个角色：策略接口、具体策略类和上下文类
上下文类包含一个策略接口的引用，并且可以在运行时切换具体策略类的实现
```java
// 策略接口
public interface SortStrategy {
    void sort(int[] data);
}
// 策略实现
public class BubbleSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 冒泡排序算法实现
    }
}

public class QuickSortStrategy implements SortStrategy {
    @Override
    public void sort(int[] data) {
        // 快速排序算法实现
    }
}

// 上下文类
public class Sorter {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] data) {
        strategy.sort(data);
    }
}

// 使用
int[] data = {4, 2, 1, 5, 3};
Sorter sorter = new Sorter();
sorter.setStrategy(new BubbleSortStrategy());
sorter.sort(data);

sorter.setStrategy(new QuickSortStrategy());
sorter.sort(data);
```

## 13.9、观察者模式
观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有依赖于它的观察者对象都会得到通知并自动更新
实现观察者模式需要定义两个接口：主题接口和观察者接口。主题接口定义了注册、删除和通知观察者的方法，观察者接口定义了更新自己状态的方法
最典型的应用场景就是消息订阅系统（如微博）
```java
// 被观察者类，即微博用户或话题
class Subject {
    private List<Observer> observers = new ArrayList<>(); // 观察者列表

    public void attach(Observer observer) { // 添加观察者
        observers.add(observer);
    }

    public void detach(Observer observer) { // 移除观察者
        observers.remove(observer);
    }

    public void notifyObservers(String message) { // 通知所有观察者
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 观察者接口，即微博用户
interface Observer {
    void update(String message);
}

// 具体观察者类，即关注了某个微博用户或话题的其他用户
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

// 测试代码
public class Test {
    public static void main(String[] args) {
        Subject subject = new Subject();

        ConcreteObserver user1 = new ConcreteObserver("User1");
        ConcreteObserver user2 = new ConcreteObserver("User2");
        ConcreteObserver topic1 = new ConcreteObserver("Topic1");

        subject.attach(user1);
        subject.attach(user2);
        subject.attach(topic1);

        subject.notifyObservers("Hello world!"); // 发布新消息

        subject.detach(user2); // 取消关注

        subject.notifyObservers("Goodbye!"); // 发布新消息
    }
}

```
# 14、Linux
## 14.1、防火墙常用命令
Firewalld和iptables都是Linux系统中常用的防火墙软件, Firewalld可以在运行时动态添加、删除和修改规则, 使用更加灵活
```shell
# 查看防火墙状态
systemctl status firewalld
# 查看所有开启的端口
firewall-cmd --list-ports
# 放行80端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
# 移除80端口
firewall-cmd --remove-port=80/tcp --permanent
# 重启防火墙
firewall-cmd --reload
```

## 14.2、进程号&端口号查看
```shell
# 查看java项目的进程
jsp
# 根据名称查看进程
ps -ef|grep ims
# 根据端口号查看进程(-alnp:所有连接  -tlnp:tcp连接)
netstat -alnp|grep 8090
# 根据进程号查看项目端口号
netstat -alnp|grep 119343
```
# 15、项目
### 15.1、云+2.0系统


## 3.19、mybatis原理

1. 系统启动的时候，会去创建一个sqlSessionFactory（它是一个单例对象，因为创建开销大），其中它会去加载mybatis全局配置文件和映射文件，封装到Configuration对象中。用来创建sqlSession
> 两个属性分别为：
> DataSource dataSource
> Map<String, MappedStatement> mappedStatements：key为namespace.id， value的MappedStatement对象包括入参，出参，sql语句等信息

2. sqlsession中提供了增删改查等操作的方法，在执行方法时会调用对应Executor执行器执行
3. Executor处理，如果有配置缓存，它会先走二级缓存，再走一级缓存。如果缓存中都没有查到对应的数据，才走底层的JDBC操作，实际就是调用jdbc的statement/ preparedStatement，在调用之前涉及到参数封装，在调用之后处理返回（ResultSet转成ResultType设置的类型）

> 例如：preparedStatement执行前需要把sql中的#{} 替换为 ？
> 这些步骤都是在mapper动态代理类中进行


## 3.20、mybatis插件原理（PageHelper分页原理）
mybatis插件本质就是一个拦截器，就是对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，会执行到代理对象的方法，从而执行自己编写的拦截逻辑。
具体实现：1.创建插件类，实现Interceptor接口。2. 在插件类中重写intercept()方法，实现插件功能。3. 在插件类中重写plugin()方法，返回目标对象的代理对象。4. 在插件类中重写setProperties()方法，读取配置文件中的属性。5. 在MyBatis配置文件中通过标签配置插件。
> PageHelper 的原理是通过拦截 Executor 的 query 方法，从而获取查询 SQL 语句和参数，并根据用户的分页配置信息，自动在查询语句中添加分页的 SQL 语句，最后将修改后的 SQL 语句和参数传递给 Executor 进行查询