# 1、数据结构

## 1.1、树
### 1.1.1、基本概念

树是由n（n>=1）个有限结点组成一个具有层次关系的集合。树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。树具有以下的特点：

- 每个结点有零个或多个子结点；
- 没有父结点的结点称为根结点；
- 每一个非根结点有且只有一个父结点；
- 除了根结点外，每个子结点可以分为多个不相交的子树；

>相关术语：
	节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推
	节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
	树的深度：一棵树中节点的最大深度就是树的深度，也称为高度
	父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
	子节点：一个节点含有的子树的根节点称为该节点的子节点
	节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
	兄弟节点：拥有共同父节点的节点互称为兄弟节点
	度：节点的子树数目就是节点的度
	叶子节点：度为零的节点就是叶子节点
	祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
	后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
	森林：m颗互不相交的树构成的集合就是森林
### 1.1.2、种类

![image.png|750](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311160908220.png)

### 1.1.3、二叉树

#### 1.1.3.1、二叉树介绍
二叉树也是一种特殊的树结构，但是二叉树的度最大只能为2，也就是说，二叉树中只存在度为1的结点和度为2的结点以及叶子结点
它有两种特殊的结构：满二叉树和完全二叉树
**满二叉树**： 叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点
**完全二叉树**：对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树

#### 1.1.3.2、二叉树性质

- 若规定根的层数为1，则非空二叉树的第k层最多有（2^(k-1)）个结点。
- 若规定根所在的高度为1，则高度为k的二叉树最多有（(2^k)-1）个结点。
- 对于任何一棵二叉树，如果叶子结点数为n，则度为2的结点数为n-1
- 具有n个结点的完全二叉树的深度k为log2(n+1) 上取整。
- 对于具有n个结点的完全二叉树，如果按照从上至下从左至右的顺序对所有节点从0开始编号，则对于序号为i 的结点有：
（1）若i>0，双亲序号：(i-1)/2；i=0，i为根结点编号，无双亲结点
（2）若2i+1<n，左孩子序号：2i+1，否则无左孩子
（3）若2i+2<n，右孩子序号：2i+2，否则无右孩子

#### 1.1.3.3、二叉树的遍历

1.前序遍历
前序遍历是一种访问二叉树的每一个结点的方法，它的遍历顺序是根节点，左子树，右子树

```java
	// 递归版本
	public void preOrder1(TreeNode root){
	        if(root==null){
	            return ;
	        }
	        System.out.println(root.val);
	        preOrder1(root.left);
	        preOrder1(root.right);
	}
	// 非递归版本
    public void preOrder2(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(!stack.empty()||cur!=null){
            if(cur!=null){
                //打印根节点
                System.out.print(cur.val+" ");
                //根节点入栈
                stack.push(cur);
                //访问左子树
                cur=cur.left;
            }
            else{
                cur=stack.pop().right;
            }
        }
    }
```

2.中序遍历
中序遍历的顺序是左子树、根节点、右子树，所以递归的版本可以按照前序遍历的思路来实现

```java
	// 递归版本
	public void inOrder1(TreeNode root){
        if(root==null){
            return ;
        }
        inOrder1(root.left);
        System.out.print(root.val+" ");
        inOrder1(root.right);
    }
    // 非递归版本
    public void inOrder2(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(!stack.empty()||cur!=null){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            else{
                cur=stack.pop();
                System.out.print(cur.val+" ");
                cur=cur.right;
            }
        }
    }
```

3.后序遍历

后序遍历的顺序是左子树、右子树、根节点
```java
	// 递归版本
	public void postOrder1(TreeNode root){
        if(root==null){
            return ;
        }
        postOrder1(root.left);
        postOrder1(root.right);
        System.out.println(root.val);
    }
    // 非递归版本
    public void postOrder2(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        TreeNode prev = null;
        while(cur!=null||stack.empty()){
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            TreeNode top = stack.peek();
            if(top.right==null||top.right==prev){
                System.out.print(top.val+" ");
                prev=top;
                stack.pop();
            }
            else{
                cur=top.right;
            }
        }
    }
```

### 1.1.4、二叉查找树(BST)
二叉查找树又称二叉搜索树、二叉排序树、BST(Binary Search Tree)
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；  
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；  
任意节点的左、右子树也分别为二叉查找树；  
没有键值相等的节点
查找一个节点，时间复杂度为O(n)，这是最坏的情况，单分支的情况是查找效率最低的情况，理想情况下面，时间复杂度为O(logN)，N为节点个数

#### 1.1.4.1、插入

```java
	public void insert(int val){
        if(root==null){
            root=new TreeNode(val);
            return;
        }
        TreeNode parent=null;
        TreeNode cur=root;
        while (cur!=null){
            if(cur.val<val){
                parent=cur;
                cur=cur.right;
            }
            else if(cur.val>val){
                parent=cur;
                cur=cur.left;
            }else {
                throw new RuntimeException("不能插入相同数据");
            }
        }
        TreeNode node=new TreeNode(val);
        if(parent.val<val){
            parent.right=node;
        }else {
            parent.left=node;
        }
	 }
```

#### 1.1.4.2、查找

```java
public TreeNode search(int val){
        TreeNode cur=root;
        while (cur!=null){
            if(cur.val<val){
               cur=cur.left;
            }
            else if(cur.val>val){
                cur=cur.right;
            }
            else {
                return cur;
            }
        }
        return null;
}
```


### 1.1.5、平衡二叉树

#### 1.1.5.1、AVL树

在计算机科学中，**AVL树**是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。  

AVL树本质上还是一棵二叉搜索树，它的特点是：  
- 1.本身首先是一棵二叉搜索树
- 2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。  也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）

使用场景：
- AVL树适合用于插入删除次数比较少，但查找多的情况。 
- 也在`Windows`进程地址空间管理中得到了使用

#### 1.1.5.2、红黑树

**8.红黑树**

> 红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:  
> 性质1. 节点是红色或黑色。  
> 性质2. 根节点是黑色。  
> 性质3. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)  
> 性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。  
> **使用场景：**  
> **红黑树多用于搜索,插入,删除操作多的情况下**  
> **红黑树应用比较广泛：**  
> **1. 广泛用在`C++`的`STL`中。`map`和`set`都是用红黑树实现的。**  
> **2. 著名的`linux`进程调度`Completely Fair Scheduler`,用红黑树管理进程控制块。**  
> **3.`epoll`在内核中的实现，用红黑树管理事件块**  
> **4.`nginx`中，用红黑树管理`timer`等**

**9.伸展树**

> 伸展树（Splay Tree），也叫分裂树，是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由**丹尼尔·斯立特**Daniel Sleator 和 **罗伯特·恩卓·塔扬**Robert Endre Tarjan 在1985年发明的。  
> 在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。  
> 它的优势在于不需要记录用于平衡树的冗余信息。

**10.替罪羊树**

> 替罪羊树是计算机科学中，一种基于部分重建的自平衡二叉搜索树。在替罪羊树上，插入或删除节点的平摊最坏时间复杂度是O(log n)，搜索节点的最坏时间复杂度是O(log n)。  
> 在非平衡的二叉搜索树中，每次操作以后检查操作路径，找到最高的满足max(size(son_L),size(son_R))>alpha*size(this)的结点，重建整个子树。这样就得到了替罪羊树，而被重建的子树的原来的根就被称为替罪羊节点。替罪羊树替罪羊树是一棵自平衡二叉搜索树，由ArneAndersson提出。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。

**11.B-tree（B-树或者B树）**

> 一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：  
> 1、根结点至少有两个子女；  
> 2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；  
> 3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故**内部子树**个数 k 满足：┌m/2┐ <= k <= m ；  
> 4、所有的叶子结点都位于同一层。